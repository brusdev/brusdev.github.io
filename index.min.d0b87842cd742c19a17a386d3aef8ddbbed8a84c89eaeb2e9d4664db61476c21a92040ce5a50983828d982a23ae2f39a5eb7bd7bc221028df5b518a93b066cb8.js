var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(n){const s=suggestions.classList.contains("d-none");if(s)return;const e=[...suggestions.querySelectorAll("a")];if(e.length===0)return;const t=e.indexOf(document.activeElement);if(n.key==="ArrowUp"){n.preventDefault();const s=t>0?t-1:0;e[s].focus()}else if(n.key==="ArrowDown"){n.preventDefault();const s=t+1<e.length?t+1:t;e[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/tutorials/",title:"Tutorials",description:"Tutorials ArtemisCloid.io",content:""}),e.add({id:1,href:"/docs/help/",title:"Help",description:"Help Doks.",content:""}),e.add({id:2,href:"/docs/getting-started/introduction/",title:"Introduction",description:"ArtemisCloud.io is a collection of container images that provide a way to deploy the Apache ActiveMQ Artemis Broker on Kubernetes.",content:"Welcome #\rWelcome to The ArtemisCloud documentation. This documentation is open source and can be found at here. All contributions are welcome.\nQuick Start #\rOne page summary of how to start a new Doks project. Quick Start →\nHow to contribute to the docs #\rYou can contribute to these docs by sending a Pull Request to the activemq-artemis-operator Github repository. Each chapter is a single markdown file found under the docs/manual directory. Simply update an existing chapter or add a new file for a new one. If you add a new on you should update the _index.md file with the new chapter .\nHelp #\rGet help on ArtemisCloud.io. Help →\n"}),e.add({id:3,href:"/docs/getting-started/",title:"Getting started",description:"Getting started ArtemisCloid.io",content:""}),e.add({id:4,href:"/docs/tutorials/deploybasicimage/",title:"Deploying the Basic Broker Image",description:"Deploying the Basic Broker Image.",content:"The basic Broker Container image is the easiest way to get the broker up and running as a container, we\u0026rsquo;ll explain what it is and how to run it locally.\nThe Basic Broker Container Image is the simplest of images to get started with, it uses environment variables to configure the broker and then starts it. You can find the basic Broker Container Image at quay.io\nYou can use your favourite tool to run the container but for this example we are using docker.\nAll you need to do is execute the docker run command which will download the basic Broker Image and run it locally for you, in this instance we are using the latest dev tag but you could choose a released version if needed.\ndocker run -e AMQ_USER=admin -e AMQ_PASSWORD=admin --name artemis quay.io/artemiscloud/activemq-artemis-broker:dev.latest  This now should download the latest image and run it, you should see:\ndev.latest: Pulling from artemiscloud/activemq-artemis-broker eae19a56e9c6: Pull complete be73321c7956: Pull complete 4b32e1d9d455: Pull complete Digest: sha256:891dc91d789d93ed474df00355bd173c3980158aa68cba0737a81b920fc0bf2f Status: Downloaded newer image for quay.io/artemiscloud/activemq-artemis-broker:dev.latest Creating Broker with args --user XXXXX --password XXXXX --role admin --name broker --allow-anonymous --http-host 172.17.0.2 --host 172.17.0.2 --force Creating ActiveMQ Artemis instance at: /home/jboss/broker Auto tuning journal ... done! Your system can make 0.5 writes per millisecond, your journal-buffer-timeout will be 1988000 You can now start the broker by executing: \u0026quot;/home/jboss/broker/bin/artemis\u0026quot; run Or you can run the broker in the background using: \u0026quot;/home/jboss/broker/bin/artemis-service\u0026quot; start Running Broker _ _ _ / \\ ____| |_ ___ __ __(_) _____ / _ \\| _ \\ __|/ _ \\ \\/ | |/ __/ / ___ \\ | \\/ |_/ __/ |\\/| | |\\___ \\ /_/ \\_\\| \\__\\____|_| |_|_|/___ / Apache ActiveMQ Artemis 2.16.0 2021-01-29 10:05:07,903 INFO [org.apache.activemq.artemis.integration.bootstrap] AMQ101000: Starting ActiveMQ Artemis Server ......... 2021-01-29 10:05:09,372 INFO [org.apache.activemq.artemis] AMQ241004: Artemis Console available at http://172.17.0.2:8161/console  Well done you have now deployed your first artemiscloud image. Now we want to expose the broker to the outside world so stop the broker and remove the image.\ndocker rm artemis  Now re run the broker pod and expose the broker by publishing the broker\u0026rsquo;s console port 8161 on the docker hosts machine port 80.\ndocker run -e AMQ_USER=admin -e AMQ_PASSWORD=admin -p80:8161 --name artemis quay.io/artemiscloud/activemq-artemis-broker:dev.latest  Now open up a browser and go to http://localhost/console and login using the username and password you provided in the docker command.\nLastly follow the above steps to recreate the broker image but now also pass in the params -p61616:61616 to expose the acceptor ports for all client protocols. You can now connect an external client to localhost:61616. using the Artemis CLi you can easily send some messages using..\nartemis producer  For more information on ActiveMQ Artemis please read the Artemis Documentation and for available environment properties to set you can check the image.yaml\n"}),e.add({id:5,href:"/docs/getting-started/quick-start/",title:"Quick Start",description:"One page summary of how to start a new Doks project.",content:"Overview #\rAt the moment these instructions have been tested against Kubernetes 1.20, other kubernetes or OpenShift environments may require minor adjustment.\nOne important note about operators in general is that to get the operator installed requires cluster-admin level privileges. Once installed, a regular user should be able to install ActiveMQ Artemis via the provided custom resource.\nQuick Start #\rGeneral environment requirements #\rCurrently the operator is tested against kubernetes v1.20. You can install a Minikube or a CodeReady Containers(CRC) to deploy the operator.\nGetting the code and build the image #\rTo launch the operator you will need to clone the activemq-artemis-operator and checkout the main branch.\nFollow the building instructions, tag, and push it into your project namespace.\nDeploying the operator #\rTo deploy the operator simply run\n$ make deploy  or if you have built your own image, overrides the defaults\nmake OPERATOR_IMAGE_REPO=\u0026lt;your registry url\u0026gt; OPERATOR_VERSION=\u0026lt;your tag\u0026gt; deploy  The defaults are specified in Makefile.\nThe operator will be deployed into namespace activemq-artemis-operator and watches the same namespace.\nTo watch all namespace, change the WATCH_NAMESPACE environment variable defined in config/manager/manager.yaml to be empty string before deploy the operator.\nAt this point you should see the activemq-artemis-operator starting up and if you check the logs you should see something like\n$ kubectl get pod -n activemq-artemis-operator NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 70m  Deploying the broker #\rNow that the operator is running and listening for changes related to our crd we can deploy one of our basic broker custom resource examples which looks like\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: placeholder  Note in particular the spec.image which identifies the container image to use to launch the AMQ Broker. If it\u0026rsquo;s empty or \u0026lsquo;placeholder\u0026rsquo; it will get the latest default image url from config/manager/manager.yaml where a list of supported broker image are defined as environment variables.\nTo deploy the broker simply execute\nkubectl create -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator  In a mement you should see one broker pod is created alongside the operator pod:\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 128m ex-aao-ss-0 1/1 Running 0 23m  Scaling #\rThe spec.deploymentPlan.size controls how many broker pods you want to deploy to the cluster. You can change this value and apply it to a running deployment to scale up and scale down the broker pods.\nFor example if you want to scale up the above deployment to 2 pods, modify the size to 2:\nexamples/artemis-basic-deployment.yaml\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 2 image: placeholder  and apply it:\nkubectl apply -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator  and you will get 2 broker pods in the cluster\nkubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 140m ex-aao-ss-0 1/1 Running 0 35m ex-aao-ss-1 1/1 Running 0 69s  You can scale down the deployment in similar manner by reducing the size and apply it again.\nClustering #\rBy default if broker pods are scaled to more than one then the broker pods form a broker cluster, meaning connect to each other and redistribute messages using default \u0026lsquo;ON_DEMAND\u0026rsquo; policy.\nUndeploying the broker #\rTo undeploy the broker we simply execute\n$ kubectl delete -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator activemqartemis.broker.amq.io \u0026quot;ex-aao\u0026quot; deleted  Managing Queues #\rOverview #\rUsers can use the activemqartemisaddress CRD to create and remove queues/address on a running broker pod.\nFor example suppose you have deployed a broker pod like above, you can deploy an activemqartemisaddress resouce from the examples dir:\naddress-queue-create-auto-removed.yaml:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemisAddress metadata: name: ex-aaoaddress spec: addressName: myAddress0 queueName: myQueue0 routingType: anycast removeFromBrokerOnDelete: true  and the deploy command:\n$ kubectl create -f examples/address-queue-create-auto-removed.yaml -n activemq-artemis-operator activemqartemisaddress.broker.amq.io/ex-aaoaddress created  When it is deployed it will create a queue named myQueue0 on an address myAddress0 with anycast routing type.\nThe spec.removeFromBrokerOnDelete controls how to deal with the created queue/address resources when you delete the above custom resource:\n$ kubectl delete -f examples/address-queue-create-auto-removed.yaml -n activemq-artemis-operator activemqartemisaddress.broker.amq.io \u0026quot;ex-aaoaddress\u0026quot; deleted  If spec.removeFromBrokerOnDelete is true, the queue/address resources will be deleted from broker. If it is false, the queue/address created by this custome resource will be kept in broker even after the custom resource has been deleted.\nDraining messages on scale down #\rWhen a broker pod is being scaled down, a scaledown controller can be deployed aumatically to handle message migration from the scaled down broker pod to an active broker.\nWhen the scale down controller detects the event it starts a drainer pod. The drainer pod will contact one of the live pods in the cluster and drain the messages over to it. After the draining is complete it shuts down itself.\nThe message draining only works when you enabled persistence and messageMigration on broker custome resource. For example create a broker.yaml with the following content:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 2 image: placeholder persistenceEnabled: true messageMigration: true  To demonstrate the message draining first deploy the above custom resource (assuming the operator is running):\n$ kubectl create -f broker.yaml -n activemq-artemis-operator activemqartemis.broker.amq.io/ex-aao created  You shall see 2 broker pods are created.\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 3h19m ex-aao-ss-0 1/1 Running 0 89s ex-aao-ss-1 1/1 Running 0 53s  Now we\u0026rsquo;ll use broker\u0026rsquo;s cli tool to send some messages to each broker pod.\nFirst send 100 messages to broker ex-aao-ss-0:\nkubectl exec ex-aao-ss-0 -- amq-broker/bin/artemis producer --user x --password y --url tcp://ex-aao-ss-0:61616 --message-count=100 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-0:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 409 milli seconds  then send another 100 messages to broker ex-aao-ss-1\nkubectl exec ex-aao-ss-1 -- amq-broker/bin/artemis producer --user x --password y --url tcp://ex-aao-ss-1:61616 --message-count=100 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-1:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 466 milli seconds  Now each of the 2 brokers has 100 messages. Modify the broker.yaml to scale down to one broker\nbroker.yaml\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: placeholder persistenceEnabled: true messageMigration: true  and re-apply it:\nkubectl apply -f broker.yaml -n activemq-artemis-operator  The broker pods will be reduced to only one\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 3h57m ex-aao-ss-0 1/1 Running 0 39m  Now the messages on the broker pod ex-aao-ss-1 should have been all migrated to pod ex-aao-ss-0. Use the broker cli tool again to check:\nkubectl exec ex-aao-ss-0 -- amq-broker/bin/artemis queue stat --user x --password y --url tcp://ex-aao-ss-0:61616 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |$.artemis.internal.sf.my-cluster.941368e6-79c9-11ec-b4c8-0242ac11000b|$.artemis.internal.sf.my-cluster.941368e6-79c9-11ec-b4c8-0242ac11000b|0 |0 |0 |0 |0 |0 |MULTICAST | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |TEST |TEST |0 |200 |200 |0 |0 |0 |ANYCAST | |activemq.management.91b87b03-0c70-4630-beb8-6a7919a4923a|activemq.management.91b87b03-0c70-4630-beb8-6a7919a4923a|1 |0 |0 |0 |0 |0 |MULTICAST |  You can see the queue TEST has 200 messages now.\nUndeploying the operator #\rRun this command to undeploy the operator\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; undeploy  "}),e.add({id:6,href:"/docs/tutorials/using_operator/",title:"Getting Started with the ArtemisCloud Operator",description:"Steps to get operator up and running and basic broker operations",content:"The ArtemisCloud Operator is a powerful tool that allows you to configure and manage ActiveMQ Artemis broker resources in a cloud environment. You can get the Operator running in just a few steps.\nPrerequisite #\rBefore you start, you need to have access to a running Kubernetes cluster environment. A Minikube instance running on your laptop will do fine. The ArtemisCloud Operator can also run in an Openshift cluster environment such as CodeReady Containers.\nIn this blog post, we assume that you have a Kubernetes cluster environment.\nNOTE: If you use CodeReady Containers, the client tool is oc rather than kubectl\nStep 1 - Preparing for deployment #\rClone the ArtemisCloud Operator repo:\n$ git clone https://github.com/artemiscloud/activemq-artemis-operator.git  We will use a namespace called myproject to deploy the operator and other resources. If you don\u0026rsquo;t specify a namespace the default namespace will be used.\nThe following command will create the namespace:\n$ kubectl create namespace myproject namespace/myproject created  Go to the root of the local repo and set up the service account and permissions needed for Operator deployment:\n$ cd activemq-artemis-operator $ kubectl create -f deploy/service_account.yaml --namespace myproject $ kubectl create -f deploy/role.yaml --namespace myproject $ kubectl create -f deploy/role_binding.yaml --namespace myproject  Deploy all the Custom Resource Definitions (CRDs) that the Operator supports:\n# Broker CRD $ kubectl create -f deploy/crds/broker_activemqartemis_crd.yaml # Address CRD $ kubectl create -f deploy/crds/broker_activemqartemisaddress_crd.yaml # Scaledown CRD $ kubectl create -f deploy/crds/broker_activemqartemisscaledown_crd.yaml   NOTE: You might see some warning messages while deploying the CRDs. For example: \u0026ldquo;Warning: apiextensions.k8s.io/v1beta1 CustomResourceDefinition is deprecated in v1.16+, unavailable in v1.22+; use apiextensions.k8s.io/v1 CustomResourceDefinition customresourcedefinition.apiextensions.k8s.io/activemqartemises.broker.amq.io created\u0026rdquo;. You can safely ignore these warnings.\n Step 2 - Deploying the Operator #\rDeploy the Operator:\n$ kubectl create -f deploy/operator.yaml --namespace myproject deployment.apps/activemq-artemis-operator created  You might need to wait a few moments for the Operator to fully start. You can verify the Operator status by running the command and looking at the output:\n$ kubectl get pod --namespace myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-gthwb 1/1 Running 0 12s  Make sure that the STATUS is Running.\nBy default the operator watches the namespace where it is deployed (i.e. myproject) for any custome resources it supports.\nStep 3 - Deploying ActiveMQ Artemis Broker in the cloud #\rNow, with a running Operator, it\u0026rsquo;s time to deploy the broker via a Custom Resource (CR) instance:\nkubectl create -f deploy/examples/artemis-basic-deployment.yaml -n myproject  Watch the broker Pod start up:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-gthwb 1/1 Running 0 14m ex-aao-ss-0 1/1 Running 0 61s  Behind the scenes, the Operator watches CR deployments in the target namespace. When the broker CR is deployed, the Operator configures and deploys the broker Pod into the cluster.\nTo see details for startup of the broker Pod you can get the console log from the Pod:\n$ kubectl logs ex-aao-ss-0 -n myproject -XX:+UseParallelOldGC -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=20 -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90 -XX:MaxMetaspaceSize=100m -XX:+ExitOnOutOfMemoryError Removing provided -XX:+UseParallelOldGC in favour of artemis.profile provided option Running server env: home: /home/jboss AMQ_HOME /opt/amq CONFIG_BROKER false RUN_BROKER NO RUN_BROKER defined Using custom configuration. Copy from /amq/init/config to /home/jboss/amq-broker bin data etc lib log tmp Running Broker in /home/jboss/amq-broker OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N _ _ _ / \\ ____| |_ ___ __ __(_) _____ / _ \\| _ \\ __|/ _ \\ \\/ | |/ __/ / ___ \\ | \\/ |_/ __/ |\\/| | |\\___ \\ /_/ \\_\\| \\__\\____|_| |_|_|/___ / Apache ActiveMQ Artemis 2.16.0 2021-02-18 06:00:06,958 INFO [org.apache.activemq.artemis.integration.bootstrap] AMQ101000: Starting ActiveMQ Artemis Server 2021-02-18 06:00:07,033 INFO [org.apache.activemq.artemis.core.server] AMQ221000: live Message Broker is starting with configuration Broker Configuration (clustered=true,journalDirectory=data/journal,bindingsDirectory=data/bindings,largeMessagesDirectory=data/large-messages,pagingDirectory=data/paging) 2021-02-18 06:00:07,186 INFO [org.apache.activemq.artemis.core.server] AMQ221013: Using NIO Journal 2021-02-18 06:00:07,349 INFO [org.apache.activemq.artemis.core.server] AMQ221057: Global Max Size is being adjusted to 1/2 of the JVM max size (-Xmx). being defined as 1,045,430,272 2021-02-18 06:00:07,781 WARNING [org.jgroups.stack.Configurator] JGRP000014: BasicTCP.use_send_queues has been deprecated: will be removed in 4.0 2021-02-18 06:00:07,814 WARNING [org.jgroups.stack.Configurator] JGRP000014: Discovery.timeout has been deprecated: GMS.join_timeout should be used instead 2021-02-18 06:00:07,943 INFO [org.jgroups.protocols.openshift.DNS_PING] serviceName [ex-aao-ping-svc] set; clustering enabled 2021-02-18 06:00:11,047 INFO [org.openshift.ping.common.Utils] 3 attempt(s) with a 1000ms sleep to execute [GetServicePort] failed. Last failure was [javax.naming.NameNotFoundException: DNS name not found [response code 3]] 2021-02-18 06:00:11,048 WARNING [org.jgroups.protocols.openshift.DNS_PING] No DNS SRV record found for service [ex-aao-ping-svc] ------------------------------------------------------------------- GMS: address=ex-aao-ss-0-6103, cluster=activemq_broadcast_channel, physical address=172.17.0.4:7800 ------------------------------------------------------------------- 2021-02-18 06:00:14,217 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-server]. Adding protocol support for: CORE 2021-02-18 06:00:14,219 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-amqp-protocol]. Adding protocol support for: AMQP 2021-02-18 06:00:14,221 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-hornetq-protocol]. Adding protocol support for: HORNETQ 2021-02-18 06:00:14,226 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-mqtt-protocol]. Adding protocol support for: MQTT 2021-02-18 06:00:14,227 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-openwire-protocol]. Adding protocol support for: OPENWIRE 2021-02-18 06:00:14,228 INFO [org.apache.activemq.artemis.core.server] AMQ221043: Protocol module found: [artemis-stomp-protocol]. Adding protocol support for: STOMP 2021-02-18 06:00:14,327 INFO [org.apache.activemq.artemis.core.server] AMQ221034: Waiting indefinitely to obtain live lock 2021-02-18 06:00:14,328 INFO [org.apache.activemq.artemis.core.server] AMQ221035: Live Server Obtained live lock 2021-02-18 06:00:14,510 INFO [org.apache.activemq.artemis.core.server] AMQ221080: Deploying address DLQ supporting [ANYCAST] 2021-02-18 06:00:14,539 INFO [org.apache.activemq.artemis.core.server] AMQ221003: Deploying ANYCAST queue DLQ on address DLQ 2021-02-18 06:00:14,658 INFO [org.apache.activemq.artemis.core.server] AMQ221080: Deploying address ExpiryQueue supporting [ANYCAST] 2021-02-18 06:00:14,660 INFO [org.apache.activemq.artemis.core.server] AMQ221003: Deploying ANYCAST queue ExpiryQueue on address ExpiryQueue 2021-02-18 06:00:15,019 INFO [org.apache.activemq.artemis.core.server] AMQ221020: Started EPOLL Acceptor at ex-aao-ss-0.ex-aao-hdls-svc.myproject.svc.cluster.local:61616 for protocols [CORE] 2021-02-18 06:00:15,022 INFO [org.apache.activemq.artemis.core.server] AMQ221007: Server is now live 2021-02-18 06:00:15,023 INFO [org.apache.activemq.artemis.core.server] AMQ221001: Apache ActiveMQ Artemis Message Broker version 2.16.0 [amq-broker, nodeID=8d13dfd2-71ae-11eb-b7ec-0242ac110004] 2021-02-18 06:00:15,981 INFO [org.apache.activemq.hawtio.branding.PluginContextListener] Initialized activemq-branding plugin 2021-02-18 06:00:16,075 INFO [org.apache.activemq.hawtio.plugin.PluginContextListener] Initialized artemis-plugin plugin 2021-02-18 06:00:16,724 INFO [io.hawt.HawtioContextListener] Initialising hawtio services 2021-02-18 06:00:16,763 INFO [io.hawt.system.ConfigManager] Configuration will be discovered via system properties 2021-02-18 06:00:16,782 INFO [io.hawt.jmx.JmxTreeWatcher] Welcome to Hawtio 2.11.0 2021-02-18 06:00:16,816 INFO [io.hawt.web.auth.AuthenticationConfiguration] Starting hawtio authentication filter, JAAS realm: \u0026quot;activemq\u0026quot; authorized role(s): \u0026quot;admin\u0026quot; role principal classes: \u0026quot;org.apache.activemq.artemis.spi.core.security.jaas.RolePrincipal\u0026quot; 2021-02-18 06:00:16,855 INFO [io.hawt.web.proxy.ProxyServlet] Proxy servlet is disabled 2021-02-18 06:00:16,866 INFO [io.hawt.web.servlets.JolokiaConfiguredAgentServlet] Jolokia overridden property: [key=policyLocation, value=file:/home/jboss/amq-broker/etc/jolokia-access.xml] 2021-02-18 06:00:17,038 INFO [org.apache.activemq.artemis] AMQ241001: HTTP Server started at http://ex-aao-ss-0.ex-aao-hdls-svc.myproject.svc.cluster.local:8161 2021-02-18 06:00:17,038 INFO [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available at http://ex-aao-ss-0.ex-aao-hdls-svc.myproject.svc.cluster.local:8161/console/jolokia 2021-02-18 06:00:17,039 INFO [org.apache.activemq.artemis] AMQ241004: Artemis Console available at http://ex-aao-ss-0.ex-aao-hdls-svc.myproject.svc.cluster.local:8161/console  Step 4 - Create a queue using the Operator #\rNow, let\u0026rsquo;s create a message queue in the broker:\n$ kubectl create -f deploy/examples/address-queue-create-auto-removed.yaml -n myproject activemqartemisaddress.broker.amq.io/ex-aaoaddress created  The address-queue-create-auto-removed.yaml is another CR supported by the ArtemisCloud Operator. Its content is shown below:\napiVersion: broker.amq.io/v2alpha2 kind: ActiveMQArtemisAddress metadata: name: ex-aaoaddress spec: addressName: myAddress0 queueName: myQueue0 routingType: anycast removeFromBrokerOnDelete: true  The CR tells the Operator to create a queue named myQueue0 on address myAddress0 on each broker that it manages.\nAfter the CR is deployed, you can observe the queue on the broker:\n\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis queue stat --user admin --password admin --url tcp://ex-aao-ss-0:61616 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |activemq.management.a5037b80-fbb7-48b8-93d2-f505d7a39aae|activemq.management.a5037b80-fbb7-48b8-93d2-f505d7a39aae|1 |0 |0 |0 |0 |0 |MULTICAST | |myQueue0 |myAddress0 |0 |0 |0 |0 |0 |0 |ANYCAST |  Step 5 - Sending and Receiving messages #\rFinally, you can send some messages to the broker and receive them. Here, we use the artemis CLI tool that comes with the deployed broker instance for the test.\nSend 100 messages:\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis producer --user admin --password admin --url tcp://ex-aao-ss-0:61616 --destination myQueue0::myAddress0 --message-count 100 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 Producer ActiveMQQueue[myQueue0::myAddress0], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[myQueue0::myAddress0], thread=0 Produced: 100 messages Producer ActiveMQQueue[myQueue0::myAddress0], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[myQueue0::myAddress0], thread=0 Elapsed time in milli second : 505 milli seconds  Now, if you check the queue statistics using the command mentioned in Step 4, you see that the message count is 100:\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis queue stat --user admin --password admin --url tcp://ex-aao-ss-0:61616 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |activemq.management.67ad22bd-f726-4b56-8949-fa37e214842c|activemq.management.67ad22bd-f726-4b56-8949-fa37e214842c|1 |0 |0 |0 |0 |0 |MULTICAST | |myAddress0 |myQueue0 |0 |100 |100 |0 |0 |0 |ANYCAST | |myQueue0 |myAddress0 |0 |0 |0 |0 |0 |0 |ANYCAST |  Further information #\r ArtemisCloud Github Repo  "}),e.add({id:7,href:"/docs/tutorials/scaleup_and_scaledown/",title:"Scaling Up and Down Brokers with ArtemisCloud Operator",description:"How to use operator to scale up and down broker pods",content:"With ArtemisCloud operator one can easily manage the broker clusters. Either scaling up number of nodes(pods) when workload is high, or scaling down when some is not needed \u0026ndash; without messages being lost or stuck.\nPrerequisite #\rBefore you start you need have access to a running Kubernetes cluster environment. A Minikube running on your laptop will just do fine. The ArtemisCloud operator also runs in a Openshift cluster environment like CodeReady Container. In this blog we assume you have Kubernetes cluster environment. (If you use CodeReady the client tool is oc in place of kubectl)\nStep 1 - Deploy ArtemisCloud Operator #\rIn this article we are using the artemiscloud operator repo. In case you haven\u0026rsquo;t done so, clone it to your local disk:\n$ git clone https://github.com/artemiscloud/activemq-artemis-operator.git $ cd activemq-artemis-operator  If you are not sure how to deploy the operator take a look at this tutorial.\nIn this blog post we assume you deployed the operator to a namespace called myproject.\nAfter deployment is done, check the operator is up and running. For example run the following command:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-m9rfr 1/1 Running 0 2m46s  Step 2 - Deploy ActiveMQ Artemis broker #\rIn this step we\u0026rsquo;ll setup a one-node broker in kubernetes. First we need create a broker custom resource file.\nUse your favorite text editor to create a file called artemis-clustered.yaml under your repo root directory with the following content:\n\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1 persistenceEnabled: true messageMigration: true  Save it and deploy it using the following command:\n$ kubectl create -f artemis-clustered.yaml -n myproject activemqartemis.broker.amq.io/ex-aao created  The custom resource file tells the operator to deploy one broker pod from the image quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1, configured with persistenceEnabled: true and messageMigration: true.\npersistenceEnabled: true means the broker persists messages to persistent storage.\nmessageMigration: true means if a broker pod is shut down, its messages will be migrated to another live broker pod so that those messages will be processed.\nIn a while the broker pod should be up and running:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-m9rfr 1/1 Running 0 7m14s ex-aao-ss-0 1/1 Running 0 83s  Step 3 - Scaling up #\rTo inform the operator that we want to scale from one to two broker pods modify artemis-clustered.yaml file to set the size to 2\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 2 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1 persistenceEnabled: true messageMigration: true  and apply it:\n$ kubectl apply -f artemis-clustered.yaml -n myproject  Verify that 2 pods are spawned up in a while:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-m9rfr 1/1 Running 0 12m ex-aao-ss-0 1/1 Running 0 6m33s ex-aao-ss-1 1/1 Running 0 75s  Step 4 - Send messages to both brokers #\rRun the following commands to send 100 messages to each broker:\nbroker0 at pod ex-aao-ss-0\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis producer --user admin --password admin --url tcp://ex-aao-ss-0:61616 --message-count 100 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 466 milli seconds  broker1 at pod ex-aao-ss-1\n$ kubectl exec ex-aao-ss-1 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis producer --user admin --password admin --url tcp://ex-aao-ss-1:61616 --message-count 100 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-1:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 511 milli seconds  The messages are send to a queue TEST in each broker. The following commands can show the queue\u0026rsquo;s message count on each broker:\nbroker0 at pod ex-aao-ss-0\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis queue stat --user admin --password admin --url tcp://ex-aao-ss-0:61616 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |$.artemis.internal.sf.my-cluster.f5e3b3bf-71b2-11eb-ab9a-0242ac110005|$.artemis.internal.sf.my-cluster.f5e3b3bf-71b2-11eb-ab9a-0242ac110005|1 |0 |0 |0 |0 |0 |MULTICAST | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |TEST |TEST |0 |100 |100 |0 |0 |0 |ANYCAST | |activemq.management.8333dec3-8376-4b50-a9d0-f2197c55e6a8|activemq.management.8333dec3-8376-4b50-a9d0-f2197c55e6a8|1 |0 |0 |0 |0 |0 |MULTICAST | |notif.f9cf93f9-71b2-11eb-ab9a-0242ac110005.ActiveMQServerImpl_serverUUID=f5e3b3bf-71b2-11eb-ab9a-0242ac110005|activemq.notifications |1 |0 |16 |0 |16 |0 |MULTICAST |  broker1 at pod ex-aao-ss-1\n$ kubectl exec ex-aao-ss-1 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis queue stat --user admin --password admin --url tcp://ex-aao-ss-1:61616 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-1:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |$.artemis.internal.sf.my-cluster.39079f07-71b2-11eb-88be-0242ac110004|$.artemis.internal.sf.my-cluster.39079f07-71b2-11eb-88be-0242ac110004|1 |0 |0 |0 |0 |0 |MULTICAST | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |TEST |TEST |0 |100 |100 |0 |0 |0 |ANYCAST | |activemq.management.2a56ebf0-37ad-4cad-9b45-b84cb148f2ff|activemq.management.2a56ebf0-37ad-4cad-9b45-b84cb148f2ff|1 |0 |0 |0 |0 |0 |MULTICAST | |notif.fa438b23-71b2-11eb-88be-0242ac110004.ActiveMQServerImpl_serverUUID=39079f07-71b2-11eb-88be-0242ac110004|activemq.notifications |1 |0 |12 |0 |12 |0 |MULTICAST |  Step 5 - Scale down with message draining #\rThe operator not only can scale up brokers in a cluster but also can scale them down. Now we have messages on both brokers. If we scale one broker down, will the messsages go offline with it and stuck in its persistence store?\nThe answer is no. As we set messageMigration: true in the broker cr, the operator will automatically \u0026ldquo;migrate\u0026rdquo; the messages on a scaled down broker pod to one of the live broker pod, a process called \u0026ldquo;message draining\u0026rdquo;.\nInternally when the operator detects that a broker pod is down, it starts up a \u0026ldquo;drainer\u0026rdquo; broker pod who has access to the down pod\u0026rsquo;s persistence store. It loads the messages in the store and sends those messages to a target live broker pod. When this is done the \u0026ldquo;drainer\u0026rdquo; pod shuts down itself.\nNow scale down the cluster from 2 pods to one. Edit the broker cr file and change the size back to 1:\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1 persistenceEnabled: true messageMigration: true  Apply it:\n$ kubectl apply -f artemis-clustered.yaml -n myproject activemqartemis.broker.amq.io/ex-aao configured  In a moment the broker pods will go down to 1. To check, run\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-m9rfr 1/1 Running 0 26m ex-aao-ss-0 1/1 Running 0 20m  Now check the messages in queue TEST at the pod again:\n$ kubectl exec ex-aao-ss-0 -n myproject -- /bin/bash /home/jboss/amq-broker/bin/artemis queue stat --user admin --password admin --url tcp://ex-aao-ss-0:61616 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |$.artemis.internal.sf.my-cluster.f5e3b3bf-71b2-11eb-ab9a-0242ac110005|$.artemis.internal.sf.my-cluster.f5e3b3bf-71b2-11eb-ab9a-0242ac110005|0 |0 |0 |0 |0 |0 |MULTICAST | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |TEST |TEST |0 |200 |200 |0 |0 |0 |ANYCAST | |activemq.management.8ee46c3d-c2ba-4e1c-9b6c-f2631e662cb1|activemq.management.8ee46c3d-c2ba-4e1c-9b6c-f2631e662cb1|1 |0 |0 |0 |0 |0 |MULTICAST |  It shows queue TEST\u0026rsquo;s message count is 200 now!\nMore information #\r Check out artemiscloud project repo Reach the dev team at slack for questions/issues/help  "}),e.add({id:8,href:"/docs/tutorials/ssl_broker_setup/",title:"Setting up SSL connections with ArtemisCloud Operator",description:"An example for setting up ssl connections for broker in kubernetes with operator",content:"Security is always a concern in a production environment. With ArtemisCloud Operator You can easily configure and set up a broker with ssl-enabled acceptors. The blog explains how to do it.\nThe ActiveMQ Artemis broker supports a variety of network protocols(tcp, http, etc) including SSL(TLS) secure connections. Underneath it uses Netty as the base transport layer.\nThis article guides you through the steps to set up a broker to run in kubernetes (Minikube). The broker will listen on a secure port 61617 (ssl over tcp). It also demonstrates sending and receiving messages over secure connections using one-way authentication.\nPrerequisite #\rBefore you start you need have access to a running Kubernetes cluster environment. A Minikube running on your laptop will just do fine. The ArtemisCloud operator also runs in a Openshift cluster environment like CodeReady Container. In this blog we assume you have Kubernetes cluster environment. (If you use CodeReady the client tool is oc in place of kubectl)\nDeploy ArtemisCloud operator #\rFirst you need to deploy the ArtemisCloud operator. If you are not sure how to deploy the operator take a look at this blog.\nIn this blog post we assume you deployed the operator to a namespace called myproject.\nMake sure the operator is in \u0026ldquo;Runing\u0026rdquo; status before going to the next step. You can run this command and observe the output:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-zcqmw 1/1 Running 0 7m32s  Prepare keystore and truststore #\rTo establish a SSL connection you need certificates. Here for demonstration purpose we prepare a self-signed certificate.\nWe\u0026rsquo;ll use the \u0026ldquo;keytool\u0026rdquo; utility that comes with JDK:\n$ keytool -genkeypair -alias artemis -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore broker.ks -validity 3000 Enter keystore password: Re-enter new password: What is your first and last name? [Unknown]: Howard Gao What is the name of your organizational unit? [Unknown]: JBoss What is the name of your organization? [Unknown]: Red Hat What is the name of your City or Locality? [Unknown]: Beijing What is the name of your State or Province? [Unknown]: Beijing What is the two-letter country code for this unit? [Unknown]: CN Is CN=Howard Gao, OU=JBoss, O=Red Hat, L=Beijing, ST=Beijing, C=CN correct? [no]: yes  It creates a keystore file named broker.ks under the current directory. Let\u0026rsquo;s give the password as password when prompted above.\nNext make a truststore using the same cert in the keystore.\n$ keytool -export -alias artemis -file broker.cert -keystore broker.ks Enter keystore password: Certificate stored in file \u0026lt;broker.cert\u0026gt;  $ keytool -import -v -trustcacerts -alias artemis -file broker.cert -keystore client.ts Enter keystore password: Re-enter new password: Owner: CN=Howard Gao, OU=JBoss, O=Red Hat, L=Beijing, ST=Beijing, C=CN Issuer: CN=Howard Gao, OU=JBoss, O=Red Hat, L=Beijing, ST=Beijing, C=CN Serial number: 582b8fd4 Valid from: Mon Feb 08 20:17:45 CST 2021 until: Fri Apr 27 20:17:45 CST 2029 Certificate fingerprints: MD5: 01:89:A9:B0:07:A1:2F:19:FC:43:5C:27:2E:E8:D7:C3 SHA1: D4:25:61:9F:AA:B6:05:1F:CC:F0:CD:65:A8:BC:B0:E1:70:49:1B:81 SHA256: 64:63:4E:68:2E:98:59:DA:A4:6B:FF:8E:E7:8C:AC:65:A2:F2:37:CB:12:BC:96:3C:AE:70:44:63:BD:0D:41:AE Signature algorithm name: SHA256withRSA Subject Public Key Algorithm: 2048-bit RSA key Version: 3 Extensions: #1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier [ KeyIdentifier [ 0000: C6 35 D2 14 85 C3 A2 68 E5 A3 78 D3 9F 3F D2 C7 .5.....h..x..?.. 0010: 8F 9D B6 A9 .... ] ] Trust this certificate? [no]: yes Certificate was added to keystore [Storing client.ts]  Make sure the password for your truststore client.ts is also password.\nBy default the operator fetches the truststore and keystore from a secret in kubernetes in order to configure SSL acceptors for a broker. The secret name is deducted from broker CR\u0026rsquo;s name combined with the acceptor\u0026rsquo;s name.\nHere we\u0026rsquo;ll use \u0026ldquo;ex-aao\u0026rdquo; for CR\u0026rsquo;s name and \u0026ldquo;sslacceptor\u0026rdquo; for the acceptor\u0026rsquo;s name. So the truststore and keystore should be stored in a secret named ex-aao-sslacceptor-secret.\nRun the following command to create the secret we need:\n$ kubectl create secret generic ex-aao-sslacceptor-secret --from-file=broker.ks --from-file=client.ts --from-literal=keyStorePassword='password' --from-literal=trustStorePassword='password' -n myproject secret/ex-aao-sslacceptor-secret created  Prepare the broker CR with SSL enabled #\rNow create a file named \u0026ldquo;broker_ssl_enabled.yaml\u0026rdquo; with the following contents:\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1 acceptors: - name: sslacceptor protocols: all port: 61617 sslEnabled: true  In this broker CR we configure an acceptor named \u0026ldquo;sslacceptor\u0026rdquo; that listens on tcp port 61617. The sslEnabled: true tells the operator to make this acceptor to use SSL transport.\nDeploy the broker #\rDeploy the above broker_ssl_enabled.yaml to the cluster:\n$ kubectl create -f broker_ssl_enabled.yaml -n myproject activemqartemis.broker.amq.io/ex-aao created  In a moment the broker should be up and running. Run the command to check it out:\n$ kubectl get pod -n myproject NAME READY STATUS RESTARTS AGE activemq-artemis-operator-58bb658f4c-zcqmw 1/1 Running 0 18m ex-aao-ss-0 1/1 Running 0 71s  Using \u0026ldquo;kubectl logs ex-aao-ss-0 -n myproject\u0026rdquo; command you can checkout the console log of the broker. You\u0026rsquo;ll be seeing a line like this in the log:\n2021-02-08 12:54:12,837 INFO [org.apache.activemq.artemis.core.server] AMQ221020: Started EPOLL Acceptor at ex-aao-ss-0.ex-aao-hdls-svc.default.svc.cluster.local:61617 for protocols [CORE,MQTT,AMQP,HORNETQ,STOMP,OPENWIRE]  which means the acceptor is now listening on port 61617. Although it doesn\u0026rsquo;t give us whether it\u0026rsquo;s SSL or plain tcp we can check out in the following steps that it accepts SSL connections only.\nOne way to check out that this acceptor is indeed SSL enabled is to log in to the broker pod and take a look at it\u0026rsquo;s configure file in /home/jboss/amq-broker/etc/broker.xml. In it there should be an element like this:\n\u0026lt;acceptor name=\u0026quot;sslacceptor\u0026quot;\u0026gt;tcp://ex-aao-ss-0.ex-aao-hdls-svc.default.svc.cluster.local:61617?protocols=AMQP,CORE,HORNETQ,MQTT,OPENWIRE,STOMP;sslEnabled=true;keyStorePath=/etc/ex-aao-sslacceptor-secret-volume/broker.ks;keyStorePassword=password;trustStorePath=/etc/ex-aao-sslacceptor-secret-volume/client.ts;trustStorePassword=password;tcpSendBufferSize=1048576;tcpReceiveBufferSize=1048576;useEpoll=true;amqpCredits=1000;amqpMinCredits=300\u0026lt;/acceptor\u0026gt;  Test messaging over a SSL connection #\rWith the broker pod in running status we can proceed to make some connections against it and do some simple messaging. We\u0026rsquo;ll use Artemis broker\u0026rsquo;s built in CLI commands to do this.\nLog into the broker pod first to get a shell command environment:\n$ kubectl exec --stdin --tty ex-aao-ss-0 -- /bin/bash [jboss@ex-aao-ss-0 ~]$  Then send 100 messages through port 61617:\n$ cd amq-broker/bin [jboss@ex-aao-ss-0 bin]$ ./artemis producer --user admin --password admin --url tcp://ex-aao-ss-0:61617?sslEnabled=true\\\u0026amp;trustStorePath=/etc/ex-aao-sslacceptor-secret-volume/client.ts\\\u0026amp;trustStorePassword=password --message-count 100 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61617?sslEnabled=true\u0026amp;trustStorePath=/etc/ex-aao-sslacceptor-secret-volume/client.ts\u0026amp;trustStorePassword=password Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 724 milli seconds  Pay attention to the \u0026ndash;url option that is required to make an SSL connection to the broker.\nYou may also wonder how it gets the trustStorePath for the connection.\nThis is because the truststore and keystore are mounted automatically by the operator when it processes the broker CR. The mount path follows the pattern derived from CR\u0026rsquo;s name (ex-aao) and the acceptor\u0026rsquo;s name (sslacceptor, thus /etc/ex-aao-sslacceptor-secret-volume).\nNow receive the messages we just sent \u0026ndash; also using SSL over the same port (61617):\n[jboss@ex-aao-ss-0 bin]$ ./artemis consumer --user admin --password admin --url tcp://ex-aao-ss-0:61617?sslEnabled=true\\\u0026amp;trustStorePath=/etc/ex-aao-sslacceptor-secret-volume/client.ts\\\u0026amp;trustStorePassword=password --message-count 100 OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N Connection brokerURL = tcp://ex-aao-ss-0:61617?sslEnabled=true\u0026amp;trustStorePath=/etc/ex-aao-sslacceptor-secret-volume/client.ts\u0026amp;trustStorePassword=password Consumer:: filter = null Consumer ActiveMQQueue[TEST], thread=0 wait until 100 messages are consumed Consumer ActiveMQQueue[TEST], thread=0 Consumed: 100 messages Consumer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Consumer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 160 milli seconds Consumer ActiveMQQueue[TEST], thread=0 Consumed: 100 messages Consumer ActiveMQQueue[TEST], thread=0 Consumer thread finished  Now you get an idea how an SSL acceptor is configured and processed by the operator and see it in action!\nMore SSL options #\rWe have just demonstrated a simplified SSL configuration. In fact the operator supports quite a few more SSL options through the CRD definitions. You can checkout those options in broker CRD down here and also read the Artemis Doc on configuring transports for more information.\n"}),e.add({id:9,href:"/docs/tutorials/initcontainer/",title:"Using the custom init image",description:"Introduction to the operator custom init image",content:"Starting from v0.18.1, the ArtemisCloud Operator enables you to specify a custom Init Container image. Specifying a custom Init Container image allows you to provide your own broker configuration within the Operator framework.\nWhat is a custom Init Container image? #\rThe ArtemisCloud Operator uses a Custom Resource Definition (CRD) to define the broker configuration. In Kubernetes, a CRD is a schema of configuration items or parameters. By creating a corresponding Custom Resource (CR) instance, you can specify values for configuration items in the CRD. For example, you can define address settings in this sample CR file.\nFor configuration that isn\u0026rsquo;t exposed in the CRD, you can specify a custom Init Container image to manipulate or add to the configuration that has been created by the Operator. When the CR is deployed and the broker instance is created, the Operator will then run a user-provided post-configuration script.\nHow it works #\rInternally, the ArtemisCloud Operator uses a specialized container called an Init Container to configure each broker instance. If no custom image for the Init Container has been specified, the Operator uses a built-in Init Container image, which is responsible for the configuration. The broker configuration generated by the Init Container is passed to the broker container image to use when launching the broker.\nIf a custom Init Container image is provided and specified in the Custom Resource (CR), then this is used to create the configuration. Since the custom image is built on top of the ArtemisCloud built-in Init Container image, the custom image first generates the broker configuration that is defined in the CR. Then, the Operator executes the post-configuration (post-config.sh) script provided by the custom Init Container.\nFor ease of use, the environment variable CONFIG_INSTANCE_DIR is set. This environment variable points to the broker instance directory, which has the following structure:\n\n${CONFIG_INSTANCE_DIR} | \\--/bin \\--/etc \\--/data \\--/lib \\--/log \\--/tmp  When the post-config.sh script is invoked, the directory specified in CONFIG_INSTANCE_DIR already contains all of the configuration files generated by the built-in image (via the configuration specified in the CR) and is available for the post-config.sh script to do extra configuration.\nFor example, a custom Init Container might be used to modify the logging settings and add or override some specific configurations in ${CONFIG_INSTANCE_DIR}/etc. In addition, the custom Init Container might put extra runtime dependencies (.jar files) in the ${CONFIG_INSTANCE_DIR}/lib directory so that the broker can use them.\nAfter the post-config.sh script is executed, the broker instance is launched with the updated configuration.\nSpecifying a custom Init Container image #\r  First, you need to implement your custom Init Container image.\nThe custom image should follow these predefined rules:\n The custom image must use the ArtemisCloud Operator\u0026rsquo;s built-in Init Container image as the base image in its Docker file. For example:  FROM quay.io/artemiscloud/activemq-artemis-broker-init:0.2.3 ...   The custom image must include a post-config.sh script in the /amq/scripts directory. The absolute path will be /amq/scripts/post-config.sh.  The post-config.sh script is where you modify the configuration of the broker or add any third party dependencies.\nIf you need additional resources (.xml files, .jar files, etc.) for your custom configuration, you need to add them to your image and make sure that they are accessible to your post-config scripts.\n  Next, you need to build your custom Init Container image and put it in a container repository (for example you can create a repository on Red Hat Quay).\n  When you have added the image to a repository, you need to configure the Operator to use the custom Init Container image. To do this, edit the CR file. For the image property, specify the custom image. For example:\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1 initImage: \u0026lt;your_custom_init_image_url\u0026gt; ...    Finally, deploy the CR file in the usual manner. For more information, see Getting Started with the ArtemisCloud Operator.\n  Further information #\r  A fully working example is available here.\n  For issues or suggestions please open an issue at ArtemisCloud.\n  "}),e.add({id:10,href:"/docs/help/building/",title:"Building",description:"Building ArtemisCloud.io",content:"Building the operator #\rGeneral environment requirements #\rA kubernetes cluster #\rCurrently the operator is tested against kubernetes v1.20. You can install a Minikube or a CodeReady Containers(CRC) to deploy the operator.\nDocker #\rCurrent version being used is v20.10. Checkout this page for help on installing docker on your specific operating system.\nGo v1.16 #\rInstall Go version v1.16 following this guide.\noperator-sdk v1.15.0 #\rInstall operator-sdk following this guide.\nGet the code #\rgit clone https://github.com/artemiscloud/activemq-artemis-operator cd activemq-artemis-operator git checkout main  Building the code locally #\rmake  or\nmake build  Building the operator image #\rThere are 2 variables you may need to override in order to push the images to your preferred registry.\nOPERATOR_IMAGE_REPO (your preferred image registry name, for example quay.io/hgao/operator  and\nOPERATOR_VERSION (the image's tag, for example v1.1)  Now build the image passing the variables\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; docker-build  If finished sucessfully it will print the image url in the end. The image url is like\n${OPERATOR_IMAGE_REPO}:${TAG}  Push the image to registry #\rdocker push ${OPERATOR_IMAGE_REPO}:${TAG}  or use the make target docker-push\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; docker-push  Now follow the quickstart to deploy the operator.\n"}),e.add({id:11,href:"/docs/help/bundle/",title:"Bundle",description:"Bundle ArtemisCloud.io",content:"Bunding A Bundle and Deploy it into the Operator Lifecycle Manager(OLM) #\rAbout the Operator Lifecycle Manager (OLM) #\rThe Operator Lifecycle Manager can help users to install and manage operators. The ArtemisCloud operator can be built into a bundle image and installed into OLM.\nBuilding #\rCreating the bundle\u0026rsquo;s manifests/metadata #\rBefore you build the bundle image generate the manifests and metadata:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; OPERATOR_IMAGE_REPO=\u0026lt;operator image registry\u0026gt; OPERATOR_VERSION=\u0026lt;operator tag\u0026gt; bundle  You\u0026rsquo;ll get some warnings like\nWARN[0001] ClusterServiceVersion validation: [OperationFailed] provided API should have an example annotation  which can be ignored. It is because the samples in the CSV only have current version.\nBuilding the bundle image: #\rmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; bundle-build  The result image tag takes the form like\n${IMAGE_TAG_BASE}-bundle:v0.0.1  Note: the version v0.0.1 is defined by VERSION variable in the Makefile\nTo push the built bundle image\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; bundle-push  Building the catalog image #\rNow with the bundle image in place, build the catalog(index) iamge:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; catalog-build  The result image tag takes the form like\n${IMAGE_TAG_BASE}-index:v0.0.1  To push the catalog image to repo:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; catalog-push  Installing operator via OLM (Minikube) #\rInstall olm (If olm is not installed already) #\rMake sure the Minikube is up and running.\nUse the operator-sdk tool:\noperator-sdk olm install  It will deploy the latest olm into Minikube.\nCreate a catalog source (e.g. catalog-source.yaml): #\rapiVersion: operators.coreos.com/v1alpha1 kind: CatalogSource metadata: name: artemis-index namespace: operators spec: sourceType: grpc image: quay.io/hgao/operator-catalog:v0.0.1 displayName: ArtemisCloud Index publisher: ArtemisCloud updateStrategy: registryPoll: interval: 10m  and deploy it:\n$ kubectl create -f catalog-source.yaml  In a moment you will see the index image is up and running in namespace operators:\n[a]$ kubectl get pod -n operators NAME READY STATUS RESTARTS AGE artemis-index-bzh75 1/1 Running 0 42s  Creating a subscription (e.g. subscription.yaml) #\rapiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: my-subscription namespace: operators spec: channel: upstream name: activemq-artemis-operator source: artemis-index sourceNamespace: operators installPlanApproval: Automatic  and deploy it:\n$ kubectl create -f subscription.yaml  An operator will be installed into operators namespace.\n$ kubectl get pod NAME READY STATUS RESTARTS AGE 9365c56f188be1738a1fabddb5a408a693d8c1f2d7275514556644e52ejpdpj 0/1 Completed 0 2m20s activemq-artemis-controller-manager-84d58db649-tkt89 1/1 Running 0 117s artemis-index-frpn4 1/1 Running 0 3m35s  "}),e.add({id:12,href:"/docs/help/custom-resources/",title:"Custom Resources",description:"Custom Resource ArtemisCloud.io",content:"Custom Resource configuration reference #\rA Custom Resource Definition (CRD) is a schema of configuration items for a custom Kubernetes object deployed with an Operator. By deploying a corresponding Custom Resource (CR) instance, you specify values for configuration items shown in the CRD.\nThe following sub-sections detail the configuration items that you can set in Custom Resource instances based on the main broker and addressing CRDs.\nBroker Custom Resource configuration reference #\rA CR instance based on the main broker CRD enables you to configure brokers for deployment in a Kubernetes project. The following is the full CRD yaml file\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemises.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemis listKind: ActiveMQArtemisList plural: activemqartemises singular: activemqartemis scope: Namespaced versions: - name: v1beta1 schema: openAPIV3Schema: description: ActiveMQArtemis is the Schema for the activemqartemises API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisSpec defines the desired state of ActiveMQArtemis properties: acceptors: description: Acceptor configuration items: properties: amqpMinLargeMessageSize: description: AMQP Minimum Large Message Size type: integer anycastPrefix: description: To indicate which kind of routing type to use. type: string connectionsAllowed: description: Max number of connections allowed to make type: integer enabledCipherSuites: description: Comma separated list of cipher suites used for SSL communication. type: string enabledProtocols: description: Comma separated list of protocols used for SSL communication. type: string expose: description: Whether or not to expose this acceptor type: boolean multicastPrefix: description: To indicate which kind of routing type to use type: string name: type: string needClientAuth: description: Tells a client connecting to this acceptor that 2-way SSL is required. This property takes precedence over wantClientAuth. type: boolean port: description: Port number format: int32 type: integer protocols: description: The protocols to enable for this acceptor type: string sniHost: description: A regular expression used to match the server_name extension on incoming SSL connections. If the name doesn't match then the connection to the acceptor will be rejected. type: string sslEnabled: description: Whether or not to enable SSL on this port type: boolean sslProvider: description: Used to change the SSL Provider between JDK and OPENSSL. The default is JDK. type: string sslSecret: description: Name of the secret to use for ssl information type: string supportAdvisory: description: For openwire protocol if advisory topics are enabled, default false type: boolean suppressInternalManagementObjects: description: If prevents advisory addresses/queues to be registered to management service, default false type: boolean verifyHost: description: The CN of the connecting client's SSL certificate will be compared to its hostname to verify they match. This is useful only for 2-way SSL. type: boolean wantClientAuth: description: Tells a client connecting to this acceptor that 2-way SSL is requested but not required. Overridden by needClientAuth. type: boolean required: - name type: object type: array addressSettings: properties: addressSetting: items: properties: addressFullPolicy: description: what happens when an address where maxSizeBytes is specified becomes full type: string autoCreateAddresses: description: whether or not to automatically create addresses when a client sends a message to or attempts to consume a message from a queue mapped to an address that doesnt exist type: boolean autoCreateDeadLetterResources: description: whether or not to automatically create the dead-letter-address and/or a corresponding queue on that address when a message found to be undeliverable type: boolean autoCreateExpiryResources: description: whether or not to automatically create the expiry-address and/or a corresponding queue on that address when a message is sent to a matching queue type: boolean autoCreateJmsQueues: description: DEPRECATED. whether or not to automatically create JMS queues when a producer sends or a consumer connects to a queue type: boolean autoCreateJmsTopics: description: DEPRECATED. whether or not to automatically create JMS topics when a producer sends or a consumer subscribes to a topic type: boolean autoCreateQueues: description: whether or not to automatically create a queue when a client sends a message to or attempts to consume a message from a queue type: boolean autoDeleteAddresses: description: whether or not to delete auto-created addresses when it no longer has any queues type: boolean autoDeleteAddressesDelay: description: how long to wait (in milliseconds) before deleting auto-created addresses after they no longer have any queues format: int32 type: integer autoDeleteCreatedQueues: description: whether or not to delete created queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteJmsQueues: description: DEPRECATED. whether or not to delete auto-created JMS queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteJmsTopics: description: DEPRECATED. whether or not to delete auto-created JMS topics when the last subscription is closed type: boolean autoDeleteQueues: description: whether or not to delete auto-created queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteQueuesDelay: description: how long to wait (in milliseconds) before deleting auto-created queues after the queue has 0 consumers. format: int32 type: integer autoDeleteQueuesMessageCount: description: the message count the queue must be at or below before it can be evaluated to be auto deleted, 0 waits until empty queue (default) and -1 disables this check. format: int32 type: integer configDeleteAddresses: description: What to do when an address is no longer in broker.xml. OFF = will do nothing addresses will remain, FORCE = delete address and its queues even if messages remaining. type: string configDeleteQueues: description: What to do when a queue is no longer in broker.xml. OFF = will do nothing queues will remain, FORCE = delete queues even if messages remaining. type: string deadLetterAddress: description: the address to send dead messages to type: string deadLetterQueuePrefix: description: the prefix to use for auto-created dead letter queues type: string deadLetterQueueSuffix: description: the suffix to use for auto-created dead letter queues type: string defaultAddressRoutingType: description: the routing-type used on auto-created addresses type: string defaultConsumerWindowSize: description: the default window size for a consumer format: int32 type: integer defaultConsumersBeforeDispatch: description: the default number of consumers needed before dispatch can start for queues under the address. format: int32 type: integer defaultDelayBeforeDispatch: description: the default delay (in milliseconds) to wait before dispatching if number of consumers before dispatch is not met for queues under the address. format: int32 type: integer defaultExclusiveQueue: description: whether to treat the queues under the address as exclusive queues by default type: boolean defaultGroupBuckets: description: number of buckets to use for grouping, -1 (default) is unlimited and uses the raw group, 0 disables message groups. format: int32 type: integer defaultGroupFirstKey: description: key used to mark a message is first in a group for a consumer type: string defaultGroupRebalance: description: whether to rebalance groups when a consumer is added type: boolean defaultGroupRebalancePauseDispatch: description: whether to pause dispatch when rebalancing groups type: boolean defaultLastValueKey: description: the property to use as the key for a last value queue by default type: string defaultLastValueQueue: description: whether to treat the queues under the address as a last value queues by default type: boolean defaultMaxConsumers: description: the maximum number of consumers allowed on this queue at any one time format: int32 type: integer defaultNonDestructive: description: whether the queue should be non-destructive by default type: boolean defaultPurgeOnNoConsumers: description: purge the contents of the queue once there are no consumers type: boolean defaultQueueRoutingType: description: the routing-type used on auto-created queues type: string defaultRingSize: description: the default ring-size value for any matching queue which doesnt have ring-size explicitly defined format: int32 type: integer enableIngressTimestamp: description: Whether or not set the timestamp of arrival on messages. default false type: boolean enableMetrics: description: whether or not to enable metrics for metrics plugins on the matching address type: boolean expiryAddress: description: the address to send expired messages to type: string expiryDelay: description: Overrides the expiration time for messages using the default value for expiration time. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer expiryQueuePrefix: description: the prefix to use for auto-created expiry queues type: string expiryQueueSuffix: description: the suffix to use for auto-created expiry queues type: string lastValueQueue: description: This is deprecated please use default-last-value-queue instead. type: boolean managementBrowsePageSize: description: how many message a management resource can browse format: int32 type: integer managementMessageAttributeSizeLimit: description: max size of the message returned from management API, default 256 format: int32 type: integer match: description: pattern for matching settings against addresses; can use wildards type: string maxDeliveryAttempts: description: how many times to attempt to deliver a message before sending to dead letter address format: int32 type: integer maxExpiryDelay: description: Overrides the expiration time for messages using a higher value. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer maxRedeliveryDelay: description: Maximum value for the redelivery-delay format: int32 type: integer maxSizeBytes: description: the maximum size in bytes for an address. -1 means no limits. This is used in PAGING, BLOCK and FAIL policies. Supports byte notation like K, Mb, GB, etc. type: string maxSizeBytesRejectThreshold: description: used with the address full BLOCK policy, the maximum size in bytes an address can reach before messages start getting rejected. Works in combination with max-size-bytes for AMQP protocol only. Default = -1 (no limit). format: int32 type: integer messageCounterHistoryDayLimit: description: how many days to keep message counter history for this address format: int32 type: integer minExpiryDelay: description: Overrides the expiration time for messages using a lower value. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer pageMaxCacheSize: description: Number of paging files to cache in memory to avoid IO during paging navigation format: int32 type: integer pageSizeBytes: description: The page size in bytes to use for an address. Supports byte notation like K, Mb, GB, etc. type: string redeliveryCollisionAvoidanceFactor: description: factor by which to modify the redelivery delay slightly to avoid collisions type: string redeliveryDelay: description: the time (in ms) to wait before redelivering a cancelled message. format: int32 type: integer redeliveryDelayMultiplier: description: multiplier to apply to the redelivery-delay type: string redistributionDelay: description: how long (in ms) to wait after the last consumer is closed on a queue before redistributing messages. format: int32 type: integer retroactiveMessageCount: description: the number of messages to preserve for future queues created on the matching address format: int32 type: integer sendToDlaOnNoRoute: description: if there are no queues matching this address, whether to forward message to DLA (if it exists for this address) type: boolean slowConsumerCheckPeriod: description: How often to check for slow consumers on a particular queue. Measured in seconds. format: int32 type: integer slowConsumerPolicy: description: what happens when a slow consumer is identified type: string slowConsumerThreshold: description: The minimum rate of message consumption allowed before a consumer is considered \u0026quot;slow.\u0026quot; Measured in messages-per-second. format: int32 type: integer slowConsumerThresholdMeasurementUnit: description: Unit used in specifying slow consumer threshold, default is MESSAGE_PER_SECOND type: string type: object type: array applyRule: description: How to merge the address settings to broker configuration type: string type: object adminPassword: description: Password for standard broker user. It is required for connecting to the broker and the web console. If left empty, it will be generated. type: string adminUser: description: User name for standard broker user. It is required for connecting to the broker and the web console. If left empty, it will be generated. type: string connectors: items: properties: enabledCipherSuites: description: Comma separated list of cipher suites used for SSL communication. type: string enabledProtocols: description: Comma separated list of protocols used for SSL communication. type: string expose: description: Whether or not to expose this connector type: boolean host: description: Hostname or IP to connect to type: string name: description: The name of the connector type: string needClientAuth: description: Tells a client connecting to this connector that 2-way SSL is required. This property takes precedence over wantClientAuth. type: boolean port: description: Port number format: int32 type: integer sniHost: description: A regular expression used to match the server_name extension on incoming SSL connections. If the name doesn't match then the connection to the acceptor will be rejected. type: string sslEnabled: description: ' Whether or not to enable SSL on this port' type: boolean sslProvider: description: Used to change the SSL Provider between JDK and OPENSSL. The default is JDK. type: string sslSecret: description: Name of the secret to use for ssl information type: string type: description: The type either tcp or vm type: string verifyHost: description: The CN of the connecting client's SSL certificate will be compared to its hostname to verify they match. This is useful only for 2-way SSL. type: boolean wantClientAuth: description: Tells a client connecting to this connector that 2-way SSL is requested but not required. Overridden by needClientAuth. type: boolean required: - host - name - port type: object type: array console: properties: expose: description: Whether or not to expose this port type: boolean sslEnabled: description: Whether or not to enable SSL on this port type: boolean sslSecret: description: Name of the secret to use for ssl information type: string useClientAuth: description: If the embedded server requires client authentication type: boolean type: object deploymentPlan: properties: clustered: description: Whether broker is clustered type: boolean enableMetricsPlugin: description: Whether or not to install the artemis metrics plugin type: boolean extraMounts: properties: configMaps: description: Name of ConfigMap items: type: string type: array secrets: description: Name of Secret items: type: string type: array type: object image: description: The image used for the broker deployment type: string initImage: description: The init container image used to configure broker type: string jolokiaAgentEnabled: description: If true enable the Jolokia JVM Agent type: boolean journalType: description: If aio use ASYNCIO, if nio use NIO for journal IO type: string livenessProbe: properties: timeoutSeconds: description: Liveness Probe timeoutSeconds for broker container format: int32 type: integer type: object managementRBACEnabled: description: If true enable the management role based access control type: boolean messageMigration: description: If true migrate messages on scaledown type: boolean persistenceEnabled: description: If true use persistent volume via persistent volume claim for journal storage type: boolean podSecurity: properties: runAsUser: description: runAsUser as defined in PodSecurityContext for the pod format: int64 type: integer serviceAccountName: description: ServiceAccount Name of the pod type: string type: object readinessProbe: properties: timeoutSeconds: description: Readiness Probe timeoutSeconds for broker container format: int32 type: integer type: object requireLogin: description: If true require user password login credentials for broker protocol ports type: boolean resources: description: ResourceRequirements describes the compute resource requirements. properties: limits: additionalProperties: anyOf: - type: integer - type: string pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$ x-kubernetes-int-or-string: true description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/' type: object requests: additionalProperties: anyOf: - type: integer - type: string pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$ x-kubernetes-int-or-string: true description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/' type: object type: object size: description: The number of broker pods to deploy format: int32 type: integer storage: properties: size: type: string type: object type: object upgrades: description: ActiveMQArtemis App product upgrade flags properties: enabled: description: Set to true to enable automatic micro version product upgrades, disabled by default. type: boolean minor: description: Set to true to enable automatic micro version product upgrades, disabled by default. Requires spec.upgrades.enabled true. type: boolean required: - enabled - minor type: object version: description: The version of the broker deployment. type: string type: object status: description: ActiveMQArtemisStatus defines the observed state of ActiveMQArtemis properties: podStatus: description: Pod Status properties: ready: description: Deployments are ready to serve requests items: type: string type: array starting: description: Deployments are starting, may or may not succeed items: type: string type: array stopped: description: Deployments are not starting, unclear what next step will be items: type: string type: array type: object required: - podStatus type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Address Custom Resource configuration reference #\rA CR instance based on the address CRD enables you to define addresses and queues for the brokers in your deployment. The following is thefull CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemisaddresses.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisAddress listKind: ActiveMQArtemisAddressList plural: activemqartemisaddresses singular: activemqartemisaddress scope: Namespaced versions: - name: v1beta1 schema: openAPIV3Schema: description: ActiveMQArtemisAddress is the Schema for the activemqartemisaddresses API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisAddressSpec defines the desired state of ActiveMQArtemisAddress properties: addressName: description: Address Name type: string applyToCrNames: description: Apply to the broker crs in the current namespace. A value of * or empty string means applying to all broker crs. Default apply to all broker crs items: type: string type: array password: description: The user's password type: string queueConfiguration: properties: autoCreateAddress: description: Whether auto create address type: boolean autoDelete: description: Auto-delete the queue type: boolean autoDeleteDelay: description: Delay (Milliseconds) before auto-delete the queue format: int64 type: integer autoDeleteMessageCount: description: Message count of the queue to allow auto delete format: int64 type: integer configurationManaged: description: ' If the queue is configuration managed' type: boolean consumerPriority: description: Consumer Priority format: int32 type: integer consumersBeforeDispatch: description: Number of consumers required before dispatching messages format: int32 type: integer delayBeforeDispatch: description: Milliseconds to wait for `consumers-before-dispatch` to be met before dispatching messages anyway format: int64 type: integer durable: description: If the queue is durable or not type: boolean enabled: description: If the queue is enabled type: boolean exclusive: description: If the queue is exclusive type: boolean filterString: description: The filter string for the queue type: string groupBuckets: description: Number of messaging group buckets format: int32 type: integer groupFirstKey: description: Header set on the first group message type: string groupRebalance: description: If rebalance the message group type: boolean groupRebalancePauseDispatch: description: If pause message dispatch when rebalancing groups type: boolean ignoreIfExists: description: If ignore if the target queue already exists type: boolean lastValue: description: If it is a last value queue type: boolean lastValueKey: description: The property used for last value queue to identify last values type: string maxConsumers: description: Max number of consumers allowed on this queue format: int32 type: integer nonDestructive: description: If force non-destructive consumers on the queue type: boolean purgeOnNoConsumers: description: Whether to delete all messages when no consumers connected to the queue type: boolean ringSize: description: The size the queue should maintain according to ring semantics format: int64 type: integer routingType: description: The routing type of the queue type: string temporary: description: If the queue is temporary type: boolean user: description: The user associated with the queue type: string required: - maxConsumers - purgeOnNoConsumers type: object queueName: description: Queue Name type: string removeFromBrokerOnDelete: description: Whether or not delete the queue from broker when CR is undeployed(default false) type: boolean routingType: description: The Routing Type type: string user: description: User name for creating the queue or address type: string type: object status: description: ActiveMQArtemisAddressStatus defines the observed state of ActiveMQArtemisAddress type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Security Custom Resource configuration reference #\rA CR instance based on the Security CRD enables you to define security for the brokers in your deployment. The following is the full CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemissecurities.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisSecurity listKind: ActiveMQArtemisSecurityList plural: activemqartemissecurities singular: activemqartemissecurity scope: Namespaced versions: - name: v1alpha1 schema: openAPIV3Schema: description: ActiveMQArtemisSecurity is the Schema for the activemqartemissecurities API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisSecuritySpec defines the desired state of ActiveMQArtemisSecurity properties: applyToCrNames: items: type: string type: array loginModules: properties: guestLoginModules: items: properties: guestRole: type: string guestUser: type: string name: type: string type: object type: array keycloakLoginModules: items: properties: configuration: properties: allowAnyHostName: type: boolean alwaysRefreshToken: type: boolean authServerUrl: type: string autoDetectBearerOnly: type: boolean bearerOnly: type: boolean clientKeyPassword: type: string clientKeyStore: type: string clientKeyStorePassword: type: string confidentialPort: format: int32 type: integer connectionPoolSize: format: int64 type: integer corsAllowedHeaders: type: string corsAllowedMethods: type: string corsExposedHeaders: type: string corsMaxAge: format: int64 type: integer credentials: items: properties: key: type: string value: type: string type: object type: array disableTrustManager: type: boolean enableBasicAuth: type: boolean enableCors: type: boolean exposeToken: type: boolean ignoreOauthQueryParameter: type: boolean minTimeBetweenJwksRequests: format: int64 type: integer principalAttribute: type: string proxyUrl: type: string publicClient: type: boolean publicKeyCacheTtl: format: int64 type: integer realm: type: string realmPublicKey: type: string redirectRewriteRules: items: properties: key: type: string value: type: string type: object type: array registerNodeAtStartup: type: boolean registerNodePeriod: format: int64 type: integer resource: type: string scope: type: string sslRequired: type: string tokenCookiePath: type: string tokenMinimumTimeToLive: format: int64 type: integer tokenStore: type: string trustStore: type: string trustStorePassword: type: string turnOffChangeSessionIdOnLogin: type: boolean useResourceRoleMappings: type: boolean verifyTokenAudience: type: boolean required: - enableBasicAuth type: object moduleType: type: string name: type: string type: object type: array propertiesLoginModules: items: properties: name: type: string users: items: properties: name: type: string password: type: string roles: items: type: string type: array type: object type: array type: object type: array type: object securityDomains: properties: brokerDomain: properties: loginModules: items: properties: debug: type: boolean flag: type: string name: type: string reload: type: boolean type: object type: array name: type: string type: object consoleDomain: properties: loginModules: items: properties: debug: type: boolean flag: type: string name: type: string reload: type: boolean type: object type: array name: type: string type: object type: object securitySettings: properties: broker: items: properties: match: type: string permissions: items: properties: operationType: type: string roles: items: type: string type: array required: - operationType type: object type: array type: object type: array management: properties: authorisation: properties: allowedList: items: properties: domain: type: string key: type: string type: object type: array defaultAccess: items: properties: method: type: string roles: items: type: string type: array type: object type: array roleAccess: items: properties: accessList: items: properties: method: type: string roles: items: type: string type: array type: object type: array domain: type: string key: type: string type: object type: array type: object connector: properties: authenticatorType: type: string host: type: string jmxRealm: type: string keyStorePassword: type: string keyStorePath: type: string keyStoreProvider: type: string objectName: type: string passwordCodec: type: string port: format: int32 type: integer rmiRegistryPort: format: int32 type: integer secured: type: boolean trustStorePassword: type: string trustStorePath: type: string trustStoreProvider: type: string type: object hawtioRoles: items: type: string type: array type: object type: object type: object status: description: ActiveMQArtemisSecurityStatus defines the observed state of ActiveMQArtemisSecurity type: object type: object served: true storage: false subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Message Migration Custom Resource configuration reference #\rA CR instance based on the address CRD enables you to define message migration for the brokers in your deployment. The following is the full CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemisscaledowns.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisScaledown listKind: ActiveMQArtemisScaledownList plural: activemqartemisscaledowns singular: activemqartemisscaledown scope: Namespaced versions: - name: v2alpha1 schema: openAPIV3Schema: description: ActiveMQArtemisScaledown is the Schema for the activemqartemisscaledowns API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisScaledownSpec defines the desired state of ActiveMQArtemisScaledown properties: localOnly: description: Triggered by main ActiveMQArtemis CRD messageMigration entry type: boolean required: - localOnly type: object status: description: ActiveMQArtemisScaledownStatus defines the observed state of ActiveMQArtemisScaledown type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  "}),e.add({id:13,href:"/docs/help/images-copy/",title:"Images",description:"Images ArtemisCloud.io",content:"Overview of the ArtemisCloud Container images #\rDocs to Follow\nThe basic Container Image #\rThe Basic Broker Container Image is the simplest of images to get started with, it uses environment variables to configure the broker and then starts it. You can find the basic Broker Container Image at quay.io\nThe Kubernetes Image #\rThe Init Image #\rThe Operator Image #\r"}),e.add({id:14,href:"/docs/help/operator/",title:"Operator",description:"Operator ArtemisCloud.io",content:"Overview of the ArtemisCloud Operator Custom Resource Definitions #\rIn general, a Custom Resource Definition (CRD) is a schema of configuration items that you can modify for a custom Kubernetes object deployed with an Operator. By creating a corresponding Custom Resource (CR) instance, you can specify values for configuration items in the CRD. If you are an Operator developer, what you expose through a CRD essentially becomes the API for how a deployed object is configured and used. You can directly access the CRD through regular HTTP curl commands, because the CRD gets exposed automatically through Kubernetes.\nThe following CRD\u0026rsquo;s are available for the Operator and can be found in the Operator Repository under config/crd/bases/\n   CRD Description     Main broker CRD Create and configure a broker deployment   Address CRD Create addresses and queues for a broker deployment   Scaledown CRD Creates a Scaledown Controller for message migration   Security CRD Configure the security and authentication method of the Broker    Additional resources #\rTo learn how to install the ActiveMQ Artemis Operator (and all included CRDs) using:\nThe Kubernetes CLI, see Installing the Operator\nFor complete configuration references to use when creating CR instances based on the main broker and address CRDs, see:\nBroker Custom Resource configuration reference\nAddress Custom Resource configuration reference\nSample Custom Reference can be found in the Operator Repository under the deploy/crs directory\nOperator deployment notes #\rThis section describes some important considerations when planning an Operator-based deployment\nDeploying the Custom Resource Definitions (CRDs) that accompany the ActiveMQ Artemis Operator requires cluster administrator privileges for your Kubernetes cluster. When the Operator is deployed, non-administrator users can create broker instances via corresponding Custom Resources (CRs). To enable regular users to deploy CRs, the cluster administrator must first assign roles and permissions to the CRDs. For more information, see Creating cluster roles for Custom Resource Definitions in the Kubernetes documentation.\nWhen you update your cluster with the CRDs for the latest Operator version, this update affects all projects in the cluster. Any broker Pods deployed from previous versions of the Operator might become unable to update their status. To fix this issue for an affected project, you must also upgrade that project to use the latest version of the Operator.\nYou cannot create more than one broker deployment in a given Kubernetes project by deploying multiple broker Custom Resource (CR) instances. However, when you have created a broker deployment in a project, you can deploy multiple CR instances for addresses.\nIf you intend to deploy brokers with persistent storage and do not have container-native storage in your Kubernetes cluster, you need to manually provision Persistent Volumes (PVs) and ensure that these are available to be claimed by the Operator. For example, if you want to create a cluster of two brokers with persistent storage (that is, by setting persistenceEnabled=true in your CR), you need to have two persistent volumes available. By default, each broker instance requires storage of 2 GiB.\nIf you specify persistenceEnabled=false in your CR, the deployed brokers uses ephemeral storage. Ephemeral storage means that every time you restart the broker Pods, any existing data is lost.\nFor more information about provisioning persistent storage in Kubernetes, see Understanding persistent storage\nInstalling the Operator using the CLI #\rThis section shows how to use the Kubernetes command-line interface (CLI) to deploy the latest version of the Operator for ArtemisCloud in your Kubernetes project.\nIf you intend to deploy brokers with persistent storage and do not have container-native storage in your Kubernetes cluster, you need to manually provision Persistent Volumes (PVs) and ensure that they are available to be claimed by the Operator. For example, if you want to create a cluster of two brokers with persistent storage (that is, by setting persistenceEnabled=true in your Custom Resource), you need to have two PVs available. By default, each broker instance requires storage of 2 GiB.\nIf you specify persistenceEnabled=false in your Custom Resource, the deployed brokers uses ephemeral storage. Ephemeral storage means that that every time you restart the broker Pods, any existing data is lost.\nGetting the Operator code #\rThis procedure shows how to access and prepare the code you need to install the latest version of the Operator for ArtemisCloud .\nDownload the latest version of the Operator from https://github.com/artemiscloud/activemq-artemis-operator/tags\nWhen the download has completed, move the archive to your chosen installation directory.\n$ mkdir ~/broker/operator $ mv activemq-artemis-operator-0.18.1.zip ~/broker/operator  In your chosen installation directory, extract the contents of the archive. For example:\n$ cd ~/broker/operator $ unzip activemq-artemis-operator-0.18.1.zip  Preparing the kubernetes Environment #\rSwitch to the directory that was created when you extracted the archive. For example:\n$ cd activemq-artemis-operator  Specify the project in which you want to install the Operator. You can create a new project or switch to an existing one.\nCreate a new namespace:\n$ kubectl create namespace \u0026lt;project-name\u0026gt;  Or, switch to an existing namespace:\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Specify a service account to use with the Operator.\nIn the deploy directory of the Operator archive that you extracted, open the service_account.yaml file.\nEnsure that the kind element is set to ServiceAccount.\nIn the metadata section, assign a custom name to the service account, or use the default name. The default name is activemq-artemis-operator.\nCreate the service account in your project.\n$ kubectl create -f deploy/service_account.yaml  Specify a role name for the Operator.\nOpen the role.yaml file. This file specifies the resources that the Operator can use and modify.\nEnsure that the kind element is set to Role.\nIn the metadata section, assign a custom name to the role, or use the default name. The default name is activemq-artemis-operator.\nCreate the role in your project.\n$ kubectl create -f deploy/role.yaml  Specify a role binding for the Operator. The role binding binds the previously-created service account to the Operator role, based on the names you specified.\nOpen the role_binding.yaml file. Ensure that the name values for ServiceAccount and Role match those specified in the service_account.yaml and role.yaml files. For example:\nmetadata: name: activemq-artemis-operator subjects: kind: ServiceAccount name: activemq-artemis-operator roleRef: kind: Role name: activemq-artemis-operator  Create the role binding in your project.\n$ kubectl create -f deploy/role_binding.yaml  In the procedure that follows, you deploy the Operator in your project.\nDeploy The Operator #\rSwitch to the directory that was created when you previously extracted the Operator installation archive. For example:\n$ cd ~/broker/operator/amq-broker-operator--ocp-install-examples  Deploy the CRDs that are included with the Operator. You must install the CRDs in your Kubernetes cluster before deploying and starting the Operator.\nDeploy the main broker CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemis_crd.yaml  Deploy the address CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemisaddress_crd.yaml  Deploy the scaledown controller CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemisscaledown_crd.yaml  In the deploy directory of the Operator archive that you downloaded and extracted, open the operator.yaml file. Ensure that the value of the spec.containers.image property is set to the latest Operator image for ActiveMQ Artemis , as shown below.\nspec: template: spec: containers: image: quay.io/artemiscloud/activemq-artemis-operator:latest  Deploy the Operator.\n$ kubectl create -f deploy/operator.yaml  In your Kubernetes project, the Operator starts in a new Pod.\nIn the Kubernetes web console, the information on the Events tab of the Operator Pod confirms that Kubernetes has deployed the Operator image that you specified, has assigned a new container to a node in your Kubernetes cluster, and has started the new container.\nIn addition, if you click the Logs tab within the Pod, the output should include lines resembling the following:\n... {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.8302743,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting Controller\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemisaddress-controller\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.830541,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting Controller\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemis-controller\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.9306898,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting workers\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemisaddress-controller\u0026quot;,\u0026quot;worker count\u0026quot;:1} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.9311671,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting workers\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemis-controller\u0026quot;,\u0026quot;worker count\u0026quot;:1}  The preceding output confirms that the newly-deployed Operator is communicating with Kubernetes, that the controllers for the broker and addressing are running, and that these controllers have started some workers.\nIt is recommended that you deploy only a single instance of the ActiveMQ Artemis Operator in a given Kubernetes project. Setting the replicas element of your Operator deployment to a value greater than 1, or deploying the Operator more than once in the same project is not recommended.\nCreating Operator-based broker deployments #\rDeploying a basic broker instance #\rThe following procedure shows how to use a Custom Resource (CR) instance to create a basic broker deployment.\nNOTE: You cannot create more than one broker deployment in a given Kubernetes project by deploying multiple Custom Resource (CR) instances. However, when you have created a broker deployment in a project, you can deploy multiple CR instances for addresses.  Prerequisites\n  You must have already installed the ArtemisCloud Operator.\n  To use the Kubernetes command-line interface (CLI) to install the ActiveMQ Artemis Operator, see Installing the Operator.\n  When you have successfully installed the Operator, the Operator is running and listening for changes related to your CRs. This example procedure shows how to use a CR instance to deploy a basic broker in your project.\n Start configuring a Custom Resource (CR) instance for the broker deployment.  Using the Kubernetes command-line interface switch to the namespace you are using for your project\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Open the sample CR file called broker_activemqartemis_cr.yaml that is included in the deploy/crs directory of the Operator installation archive that you downloaded and extracted. For a basic broker deployment, the configuration might resemble that shown below. This configuration is the default content of the broker_activemqartemis_cr.yaml sample CR.\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao application: ex-aao-app spec: version: 7.7.0 deploymentPlan: size: 2 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes: ...  Observe that the sample CR uses a naming convention of ex-aao. This naming convention denotes that the CR is an example resource for the ArtemisCloud (based on the ActiveMQ Artemis project) Operator. When you deploy this sample CR, the resulting Stateful Set uses the name ex-aao-ss. Furthermore, broker Pods in the deployment are directly based on the Stateful Set name, for example, ex-aao-ss-0, ex-aao-ss-1, and so on. The application name in the CR appears in the deployment as a label on the Stateful Set. You might use this label in a Pod selector, for example.\nThe size value specifies the number of brokers to deploy. The default value of 2 specifies a clustered broker deployment of two brokers. However, to deploy a single broker instance, change the value to 1.\nThe image value specifies the container image to use to launch the broker. Ensure that this value specifies the latest version of the ActiveMQ Artemis broker container image in the Quay.io repository, as shown below.\nimage: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1  In the preceding step, the image attribute specifies a floating image tag (that is, ) rather than a full image tag (for example, -5). When you specify this floating tag, your deployment uses the latest image available in the image stream. In addition, when you specify a floating tag such as this, if the imagePullPolicy attribute in your Stateful Set is set to Always, your deployment automatically pulls and uses new micro image versions (for example, -6, -7, and so on) when they become available from quay.io. Deploy the CR instance.\nSave the CR file.\nSwitch to the namespace in which you are creating the broker deployment.\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Create the CR.\n$ kubectl create -f \u0026lt;path/to/custom-resource-instance\u0026gt;.yaml  In the Kubernetes web console you will see a new Stateful Set called ex-aao-ss.\nClick the ex-aao-ss Stateful Set. You see that there is one Pod, corresponding to the single broker that you defined in the CR.\nWithin the Stateful Set, click the pod link and you should see the status of the pod as running. Click on the logs link in the top right corner to see the broker’s output.\nTo test that the broker is running normally, access a shell on the broker Pod to send some test messages.\nUsing the Kubernetes web console:\nClick Pods on the left menu\nClick the ex-aao-ss Pod.\nIn the top righthand corner, click the link to exec into pod\nUsing the Kubernetes command-line interface:\nGet the Pod names and internal IP addresses for your project.\n$ kubectl get pods -o wide NAME STATUS IP amq-broker-operator-54d996c Running 10.129.2.14 ex-aao-ss-0 Running 10.129.2.15  Access the shell for the broker Pod.\n$ kubectl exec --stdin --tty ex-aao-ss-0 -- /bin/bash  From the shell, use the artemis command to send some test messages. Specify the internal IP address of the broker Pod in the URL. For example:\n$ ./amq-broker/bin/artemis producer --url tcp://10.129.2.15:61616 --destination queue://demoQueue  The preceding command automatically creates a queue called demoQueue on the broker and sends a default quantity of 1000 messages to the queue.\nYou should see output that resembles the following:\nConnection brokerURL = tcp://10.129.2.15:61616 Producer ActiveMQQueue[demoQueue], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[demoQueue], thread=0 Produced: 1000 messages Producer ActiveMQQueue[demoQueue], thread=0 Elapsed time in second : 3 s Producer ActiveMQQueue[demoQueue], thread=0 Elapsed time in milli second : 3492 milli seconds  For a complete configuration reference for the main broker Custom Resource (CR), see Broker Custom Resource configuration reference.\nDeploying clustered brokers #\rIf there are two or more broker Pods running in your project, the Pods automatically form a broker cluster. A clustered configuration enables brokers to connect to each other and redistribute messages as needed, for load balancing.\nThe following procedure shows you how to deploy clustered brokers. By default, the brokers in this deployment use on demand load balancing, meaning that brokers will forward messages only to other brokers that have matching consumers.\nPrerequisites\n A basic broker instance is already deployed. See Deploying a basic broker instance.  Open the CR file that you used for your basic broker deployment.\nFor a clustered deployment, ensure that the value of deploymentPlan.size is 2 or greater. For example:\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao application: ex-aao-app spec: version: 7.7.0 deploymentPlan: size: 4 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes: ...  Save the modified CR file.\nSwitch to projects namespace:\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  At the command line, apply the change:\n$ kubectl apply -f \u0026lt;path/to/custom-resource-instance\u0026gt;.yaml  In the Kubernetes web console, additional broker Pods starts in your project, according to the number specified in your CR. By default, the brokers running in the project are clustered.\nOpen the Logs tab of each Pod. The logs show that Kubernetes has established a cluster connection bridge on each broker. Specifically, the log output includes a line like the following:\ntargetConnector=ServerLocatorImpl (identity=(Cluster-connection-bridge::ClusterConnectionBridge@6f13fb88  Applying Custom Resource changes to running broker deployments #\rThe following are some important things to note about applying Custom Resource (CR) changes to running broker deployments:\n  You cannot dynamically update the persistenceEnabled attribute in your CR. To change this attribute, scale your cluster down to zero brokers. Delete the existing CR. Then, recreate and redeploy the CR with your changes, also specifying a deployment size.\n  The value of the deploymentPlan.size attribute in your CR overrides any change you make to size of your broker deployment via the kubectl scale command. For example, suppose you use kubectl scale to change the size of a deployment from three brokers to two, but the value of deploymentPlan.size in your CR is still 3. In this case, Kubernetes initially scales the deployment down to two brokers. However, when the scaledown operation is complete, the Operator restores the deployment to three brokers, as specified in the CR.\n  As described in Deploying the Operator using the CLI, if you create a broker deployment with persistent storage (that is, by setting persistenceEnabled=true in your CR), you might need to provision Persistent Volumes (PVs) for the ArtemisCloud Operator to claim for your broker Pods. If you scale down the size of your broker deployment, the Operator releases any PVs that it previously claimed for the broker Pods that are now shut down. However, if you remove your broker deployment by deleting your CR, ArtemisCloud Operator does not release Persistent Volume Claims (PVCs) for any broker Pods that are still in the deployment when you remove it. In addition, these unreleased PVs are unavailable to any new deployment. In this case, you need to manually release the volumes. For more information, see Releasing volumes in the Kubernetes documentation.\n  During an active scaling event, any further changes that you apply are queued by the Operator and executed only when scaling is complete. For example, suppose that you scale the size of your deployment down from four brokers to one. Then, while scaledown is taking place, you also change the values of the broker administrator user name and password. In this case, the Operator queues the user name and password changes until the deployment is running with one active broker.\n  ll CR changes – apart from changing the size of your deployment, or changing the value of the expose attribute for acceptors, connectors, or the console – cause existing brokers to be restarted. If you have multiple brokers in your deployment, only one broker restarts at a time.\n  Configuring Scheduling, Preemption and Eviction #\rLiveness and Readiness Probes #\rThe Liveness and readiness Probes are used by Kubernetes to detect when the Broker is started and to check it is still alive. For full documentation on this topic refer to the Configure Liveness, Readiness and Startup Probes chapter in the Kubernetes documentation.\nThe Liveness probe #\rThe Liveness probe is configured in the Artemis CR something like:\nspec: deploymentPlan: size: 1 image: placeholder livenessProbe: initialDelaySeconds: 5 periodSeconds: 5  If no Liveness probe is configured or the handler itself is missing from a configured Liveness Probe then the Operator will create a default TCP Probe that will check the liveness of the broker by connecting to the web Server port, the default config is:\nspec: deploymentPlan: livenessProbe: tcpSocket: port: 8181 initialDelaySeconds: 30, timeoutSeconds: 5,  Using the Artemis Health Check #\ryou can also use the Artemis Health Checker to check that the broker is running, something like:\nspec: deploymentPlan: livenessProbe: exec: command: - /home/jboss/amq-broker/bin/artemis - check - node - --silent - --user - $AMQ_USER - --password - $AMQ_PASSWORD initialDelaySeconds: 30, timeoutSeconds:  By default this uses the URI of the acceptor configured with the name artemis. Since this is not configured by default it will need configuring in the broker CR. Alternatively configure the acceptor used by passing the \u0026ndash;acceptor argument on the artemis check command.\nNOTE: $AMQ_USER and $AMQ_PASSWORD are environment variables that are configured by the Operator  You can also check the status of the broker by producing and consuming a message:\nspec: deploymentPlan: livenessProbe: exec: command: - /home/jboss/amq-broker/bin/artemis - check - queue - --name - livenessqueue - --produce - \u0026quot;1\u0026quot; - --consume - \u0026quot;1\u0026quot; - --silent - --user - $AMQ_USER - --password - $AMQ_PASSWORD initialDelaySeconds: 30, timeoutSeconds:  The liveness queue must exist and be deployed the broker and be of type anycast with acceptable configuration, something like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemisAddress metadata: name: livenessqueue namespace: activemq-artemis-operator spec: addressName: livenessqueue queueConfiguration: purgeOnNoConsumers: false maxConsumers: -1 durable: true enabled: true queueName: livenessqueue routingType: anycast  NOTE: The livenessqueue queue above should should only be used by the livness probe.  The Readiness Probe #\rAs with the Liveness Probe the Readiness probe has a default probe if not configured. Unlike the readiness probe this is a script that is shipped in the Kubernetes Image, this can be found here\nThe script will try to establish a tcp connection to each port configured in the broker.xml.\nTolerations #\rIt is possible to configure tolerations on tge deployed broker image . An example of a toleration would be something like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: size: 1 tolerations: - key: \u0026quot;example-key\u0026quot; operator: \u0026quot;Exists\u0026quot; effect: \u0026quot;NoSchedule\u0026quot;  The use of Taints and Tolerations is outside the scope of this document, for full documentation see the Kubernetes Documentation\nAffinity #\rIt is possible to configure Affinity for the container pods, An example of this would be:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: disktype operator: In values: - ssd acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  Affinity is outside the scope of this document, for full documentation see the Kubernetes Documentation\nLabels and Node Selectors #\rLabels can be added to the pods by defining them like so:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: labels: location: \u0026quot;production\u0026quot; partition: \u0026quot;customerA\u0026quot; acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  It is also possible to configure a Node Selector for the container pods, this is configured like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: nodeSelector: location: \u0026quot;production\u0026quot; acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  labels Node Selectors are outside the scope of this document, for full documentation see the Kubernetes Documentation\n"}),e.add({id:15,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()