var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(n){const s=suggestions.classList.contains("d-none");if(s)return;const e=[...suggestions.querySelectorAll("a")];if(e.length===0)return;const t=e.indexOf(document.activeElement);if(n.key==="ArrowUp"){n.preventDefault();const s=t>0?t-1:0;e[s].focus()}else if(n.key==="ArrowDown"){n.preventDefault();const s=t+1<e.length?t+1:t;e[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/help/",title:"Help",description:"Help ArtemisCloud.",content:""}),e.add({id:1,href:"/docs/getting-started/introduction/",title:"Introduction",description:"ArtemisCloud.io is a collection of container images that provide a way to deploy the Apache ActiveMQ Artemis Broker on Kubernetes.",content:"Welcome # Welcome to The ArtemisCloud documentation. This documentation is open source and can be found at here. All contributions are welcome.\nQuick Start # One page summary of how to start a new ArtemisCloud project. Quick Start →\nHow to contribute to the docs # You can contribute to these docs by sending a Pull Request to the activemq-artemis-operator Github repository. Each chapter is a single markdown file found under the docs/manual directory. Simply update an existing chapter or add a new file for a new one. If you add a new on you should update the _index.md file with the new chapter .\nHelp # Get help on ArtemisCloud.io. Help →\n"}),e.add({id:2,href:"/docs/getting-started/",title:"Getting started",description:"Getting started ArtemisCloid.io",content:""}),e.add({id:3,href:"/docs/getting-started/quick-start/",title:"Quick Start",description:"One page summary of how to start a new ArtemisCloud project.",content:"Overview # At the moment these instructions have been tested against Kubernetes 1.20, other kubernetes or OpenShift environments may require minor adjustment.\nOne important note about operators in general is that to get the operator installed requires cluster-admin level privileges. Once installed, a regular user should be able to install ActiveMQ Artemis via the provided custom resource.\nGeneral environment requirements # Currently the operator is tested against kubernetes v1.20. You can install a Minikube or a CodeReady Containers(CRC) to deploy the operator.\nGetting the code and build the image # To launch the operator you will need to clone the activemq-artemis-operator and checkout the main branch.\nFollow the building instructions, tag, and push it into your project namespace.\nDeploying the operator # To deploy the operator simply run\n$ make deploy  or if you have built your own image, overrides the defaults\nmake OPERATOR_IMAGE_REPO=\u0026lt;your registry url\u0026gt; OPERATOR_VERSION=\u0026lt;your tag\u0026gt; deploy  The defaults are specified in Makefile.\nThe operator will be deployed into namespace activemq-artemis-operator and watches the same namespace.\nTo watch all namespace, change the WATCH_NAMESPACE environment variable defined in config/manager/manager.yaml to be empty string before deploy the operator.\nAt this point you should see the activemq-artemis-operator starting up and if you check the logs you should see something like\n$ kubectl get pod -n activemq-artemis-operator NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 70m  Deploying the broker # Now that the operator is running and listening for changes related to our crd we can deploy one of our basic broker custom resource examples which looks like\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: placeholder  Note in particular the spec.image which identifies the container image to use to launch the AMQ Broker. If it\u0026rsquo;s empty or \u0026lsquo;placeholder\u0026rsquo; it will get the latest default image url from config/manager/manager.yaml where a list of supported broker image are defined as environment variables.\nTo deploy the broker simply execute\nkubectl create -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator  In a mement you should see one broker pod is created alongside the operator pod:\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 128m ex-aao-ss-0 1/1 Running 0 23m  Scaling # The spec.deploymentPlan.size controls how many broker pods you want to deploy to the cluster. You can change this value and apply it to a running deployment to scale up and scale down the broker pods.\nFor example if you want to scale up the above deployment to 2 pods, modify the size to 2:\nexamples/artemis-basic-deployment.yaml\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 2 image: placeholder  and apply it:\nkubectl apply -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator  and you will get 2 broker pods in the cluster\nkubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 140m ex-aao-ss-0 1/1 Running 0 35m ex-aao-ss-1 1/1 Running 0 69s  You can scale down the deployment in similar manner by reducing the size and apply it again.\nClustering # By default if broker pods are scaled to more than one then the broker pods form a broker cluster, meaning connect to each other and redistribute messages using default \u0026lsquo;ON_DEMAND\u0026rsquo; policy.\nUndeploying the broker # To undeploy the broker we simply execute\n$ kubectl delete -f examples/artemis-basic-deployment.yaml -n activemq-artemis-operator activemqartemis.broker.amq.io \u0026quot;ex-aao\u0026quot; deleted  Managing Queues # Overview # Users can use the activemqartemisaddress CRD to create and remove queues/address on a running broker pod.\nFor example suppose you have deployed a broker pod like above, you can deploy an activemqartemisaddress resouce from the examples dir:\naddress-queue-create-auto-removed.yaml:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemisAddress metadata: name: ex-aaoaddress spec: addressName: myAddress0 queueName: myQueue0 routingType: anycast removeFromBrokerOnDelete: true  and the deploy command:\n$ kubectl create -f examples/address-queue-create-auto-removed.yaml -n activemq-artemis-operator activemqartemisaddress.broker.amq.io/ex-aaoaddress created  When it is deployed it will create a queue named myQueue0 on an address myAddress0 with anycast routing type.\nThe spec.removeFromBrokerOnDelete controls how to deal with the created queue/address resources when you delete the above custom resource:\n$ kubectl delete -f examples/address-queue-create-auto-removed.yaml -n activemq-artemis-operator activemqartemisaddress.broker.amq.io \u0026quot;ex-aaoaddress\u0026quot; deleted  If spec.removeFromBrokerOnDelete is true, the queue/address resources will be deleted from broker. If it is false, the queue/address created by this custome resource will be kept in broker even after the custom resource has been deleted.\nDraining messages on scale down # When a broker pod is being scaled down, a scaledown controller can be deployed aumatically to handle message migration from the scaled down broker pod to an active broker.\nWhen the scale down controller detects the event it starts a drainer pod. The drainer pod will contact one of the live pods in the cluster and drain the messages over to it. After the draining is complete it shuts down itself.\nThe message draining only works when you enabled persistence and messageMigration on broker custome resource. For example create a broker.yaml with the following content:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 2 image: placeholder persistenceEnabled: true messageMigration: true  To demonstrate the message draining first deploy the above custom resource (assuming the operator is running):\n$ kubectl create -f broker.yaml -n activemq-artemis-operator activemqartemis.broker.amq.io/ex-aao created  You shall see 2 broker pods are created.\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 3h19m ex-aao-ss-0 1/1 Running 0 89s ex-aao-ss-1 1/1 Running 0 53s  Now we\u0026rsquo;ll use broker\u0026rsquo;s cli tool to send some messages to each broker pod.\nFirst send 100 messages to broker ex-aao-ss-0:\nkubectl exec ex-aao-ss-0 -- amq-broker/bin/artemis producer --user x --password y --url tcp://ex-aao-ss-0:61616 --message-count=100 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-0:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 409 milli seconds  then send another 100 messages to broker ex-aao-ss-1\nkubectl exec ex-aao-ss-1 -- amq-broker/bin/artemis producer --user x --password y --url tcp://ex-aao-ss-1:61616 --message-count=100 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-1:61616 Producer ActiveMQQueue[TEST], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[TEST], thread=0 Produced: 100 messages Producer ActiveMQQueue[TEST], thread=0 Elapsed time in second : 0 s Producer ActiveMQQueue[TEST], thread=0 Elapsed time in milli second : 466 milli seconds  Now each of the 2 brokers has 100 messages. Modify the broker.yaml to scale down to one broker\nbroker.yaml\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: ex-aao spec: deploymentPlan: size: 1 image: placeholder persistenceEnabled: true messageMigration: true  and re-apply it:\nkubectl apply -f broker.yaml -n activemq-artemis-operator  The broker pods will be reduced to only one\n$ kubectl get pod NAME READY STATUS RESTARTS AGE activemq-artemis-controller-manager-5ff459cd95-kn22m 1/1 Running 0 3h57m ex-aao-ss-0 1/1 Running 0 39m  Now the messages on the broker pod ex-aao-ss-1 should have been all migrated to pod ex-aao-ss-0. Use the broker cli tool again to check:\nkubectl exec ex-aao-ss-0 -- amq-broker/bin/artemis queue stat --user x --password y --url tcp://ex-aao-ss-0:61616 Defaulted container \u0026quot;ex-aao-container\u0026quot; out of: ex-aao-container, ex-aao-container-init (init) Connection brokerURL = tcp://ex-aao-ss-0:61616 |NAME |ADDRESS |CONSUMER_COUNT |MESSAGE_COUNT |MESSAGES_ADDED |DELIVERING_COUNT |MESSAGES_ACKED |SCHEDULED_COUNT |ROUTING_TYPE | |$.artemis.internal.sf.my-cluster.941368e6-79c9-11ec-b4c8-0242ac11000b|$.artemis.internal.sf.my-cluster.941368e6-79c9-11ec-b4c8-0242ac11000b|0 |0 |0 |0 |0 |0 |MULTICAST | |DLQ |DLQ |0 |0 |0 |0 |0 |0 |ANYCAST | |ExpiryQueue |ExpiryQueue |0 |0 |0 |0 |0 |0 |ANYCAST | |TEST |TEST |0 |200 |200 |0 |0 |0 |ANYCAST | |activemq.management.91b87b03-0c70-4630-beb8-6a7919a4923a|activemq.management.91b87b03-0c70-4630-beb8-6a7919a4923a|1 |0 |0 |0 |0 |0 |MULTICAST |  You can see the queue TEST has 200 messages now.\nUndeploying the operator # Run this command to undeploy the operator\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; undeploy  "}),e.add({id:4,href:"/docs/help/building/",title:"Building",description:"Building ArtemisCloud.io",content:"Building the operator # General environment requirements # A kubernetes cluster # Currently the operator is tested against kubernetes v1.20. You can install a Minikube or a CodeReady Containers(CRC) to deploy the operator.\nDocker # Current version being used is v20.10. Checkout this page for help on installing docker on your specific operating system.\nGo v1.16 # Install Go version v1.16 following this guide.\noperator-sdk v1.15.0 # Install operator-sdk following this guide.\nGet the code # git clone https://github.com/artemiscloud/activemq-artemis-operator cd activemq-artemis-operator git checkout main  Building the code locally # make  or\nmake build  Building the operator image # There are 2 variables you may need to override in order to push the images to your preferred registry.\nOPERATOR_IMAGE_REPO (your preferred image registry name, for example quay.io/hgao/operator  and\nOPERATOR_VERSION (the image's tag, for example v1.1)  Now build the image passing the variables\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; docker-build  If finished sucessfully it will print the image url in the end. The image url is like\n${OPERATOR_IMAGE_REPO}:${TAG}  Push the image to registry # docker push ${OPERATOR_IMAGE_REPO}:${TAG}  or use the make target docker-push\nmake OPERATOR_IMAGE_REPO=\u0026lt;your repo\u0026gt; OPERATOR_VERSION=\u0026lt;tag\u0026gt; docker-push  Now follow the quickstart to deploy the operator.\n"}),e.add({id:5,href:"/docs/help/bundle/",title:"Bundle",description:"Bundle ArtemisCloud.io",content:"Bunding A Bundle and Deploy it into the Operator Lifecycle Manager(OLM) # About the Operator Lifecycle Manager (OLM) # The Operator Lifecycle Manager can help users to install and manage operators. The ArtemisCloud operator can be built into a bundle image and installed into OLM.\nBuilding # Creating the bundle\u0026rsquo;s manifests/metadata # Before you build the bundle image generate the manifests and metadata:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; OPERATOR_IMAGE_REPO=\u0026lt;operator image registry\u0026gt; OPERATOR_VERSION=\u0026lt;operator tag\u0026gt; bundle  You\u0026rsquo;ll get some warnings like\nWARN[0001] ClusterServiceVersion validation: [OperationFailed] provided API should have an example annotation  which can be ignored. It is because the samples in the CSV only have current version.\nBuilding the bundle image: # make IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; bundle-build  The result image tag takes the form like\n${IMAGE_TAG_BASE}-bundle:v0.0.1  Note: the version v0.0.1 is defined by VERSION variable in the Makefile\nTo push the built bundle image\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; bundle-push  Building the catalog image # Now with the bundle image in place, build the catalog(index) iamge:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; catalog-build  The result image tag takes the form like\n${IMAGE_TAG_BASE}-index:v0.0.1  To push the catalog image to repo:\nmake IMAGE_TAG_BASE=\u0026lt;bundle image registry\u0026gt; catalog-push  Installing operator via OLM (Minikube) # Install olm (If olm is not installed already) # Make sure the Minikube is up and running.\nUse the operator-sdk tool:\noperator-sdk olm install  It will deploy the latest olm into Minikube.\nCreate a catalog source (e.g. catalog-source.yaml): # apiVersion: operators.coreos.com/v1alpha1 kind: CatalogSource metadata: name: artemis-index namespace: operators spec: sourceType: grpc image: quay.io/hgao/operator-catalog:v0.0.1 displayName: ArtemisCloud Index publisher: ArtemisCloud updateStrategy: registryPoll: interval: 10m  and deploy it:\n$ kubectl create -f catalog-source.yaml  In a moment you will see the index image is up and running in namespace operators:\n[a]$ kubectl get pod -n operators NAME READY STATUS RESTARTS AGE artemis-index-bzh75 1/1 Running 0 42s  Creating a subscription (e.g. subscription.yaml) # apiVersion: operators.coreos.com/v1alpha1 kind: Subscription metadata: name: my-subscription namespace: operators spec: channel: upstream name: activemq-artemis-operator source: artemis-index sourceNamespace: operators installPlanApproval: Automatic  and deploy it:\n$ kubectl create -f subscription.yaml  An operator will be installed into operators namespace.\n$ kubectl get pod NAME READY STATUS RESTARTS AGE 9365c56f188be1738a1fabddb5a408a693d8c1f2d7275514556644e52ejpdpj 0/1 Completed 0 2m20s activemq-artemis-controller-manager-84d58db649-tkt89 1/1 Running 0 117s artemis-index-frpn4 1/1 Running 0 3m35s  "}),e.add({id:6,href:"/docs/help/custom-resources/",title:"Custom Resources",description:"Custom Resource ArtemisCloud.io",content:"Custom Resource configuration reference # A Custom Resource Definition (CRD) is a schema of configuration items for a custom Kubernetes object deployed with an Operator. By deploying a corresponding Custom Resource (CR) instance, you specify values for configuration items shown in the CRD.\nThe following sub-sections detail the configuration items that you can set in Custom Resource instances based on the main broker and addressing CRDs.\nBroker Custom Resource configuration reference # A CR instance based on the main broker CRD enables you to configure brokers for deployment in a Kubernetes project. The following is the full CRD yaml file\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemises.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemis listKind: ActiveMQArtemisList plural: activemqartemises singular: activemqartemis scope: Namespaced versions: - name: v1beta1 schema: openAPIV3Schema: description: ActiveMQArtemis is the Schema for the activemqartemises API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisSpec defines the desired state of ActiveMQArtemis properties: acceptors: description: Acceptor configuration items: properties: amqpMinLargeMessageSize: description: AMQP Minimum Large Message Size type: integer anycastPrefix: description: To indicate which kind of routing type to use. type: string connectionsAllowed: description: Max number of connections allowed to make type: integer enabledCipherSuites: description: Comma separated list of cipher suites used for SSL communication. type: string enabledProtocols: description: Comma separated list of protocols used for SSL communication. type: string expose: description: Whether or not to expose this acceptor type: boolean multicastPrefix: description: To indicate which kind of routing type to use type: string name: type: string needClientAuth: description: Tells a client connecting to this acceptor that 2-way SSL is required. This property takes precedence over wantClientAuth. type: boolean port: description: Port number format: int32 type: integer protocols: description: The protocols to enable for this acceptor type: string sniHost: description: A regular expression used to match the server_name extension on incoming SSL connections. If the name doesn't match then the connection to the acceptor will be rejected. type: string sslEnabled: description: Whether or not to enable SSL on this port type: boolean sslProvider: description: Used to change the SSL Provider between JDK and OPENSSL. The default is JDK. type: string sslSecret: description: Name of the secret to use for ssl information type: string supportAdvisory: description: For openwire protocol if advisory topics are enabled, default false type: boolean suppressInternalManagementObjects: description: If prevents advisory addresses/queues to be registered to management service, default false type: boolean verifyHost: description: The CN of the connecting client's SSL certificate will be compared to its hostname to verify they match. This is useful only for 2-way SSL. type: boolean wantClientAuth: description: Tells a client connecting to this acceptor that 2-way SSL is requested but not required. Overridden by needClientAuth. type: boolean required: - name type: object type: array addressSettings: properties: addressSetting: items: properties: addressFullPolicy: description: what happens when an address where maxSizeBytes is specified becomes full type: string autoCreateAddresses: description: whether or not to automatically create addresses when a client sends a message to or attempts to consume a message from a queue mapped to an address that doesnt exist type: boolean autoCreateDeadLetterResources: description: whether or not to automatically create the dead-letter-address and/or a corresponding queue on that address when a message found to be undeliverable type: boolean autoCreateExpiryResources: description: whether or not to automatically create the expiry-address and/or a corresponding queue on that address when a message is sent to a matching queue type: boolean autoCreateJmsQueues: description: DEPRECATED. whether or not to automatically create JMS queues when a producer sends or a consumer connects to a queue type: boolean autoCreateJmsTopics: description: DEPRECATED. whether or not to automatically create JMS topics when a producer sends or a consumer subscribes to a topic type: boolean autoCreateQueues: description: whether or not to automatically create a queue when a client sends a message to or attempts to consume a message from a queue type: boolean autoDeleteAddresses: description: whether or not to delete auto-created addresses when it no longer has any queues type: boolean autoDeleteAddressesDelay: description: how long to wait (in milliseconds) before deleting auto-created addresses after they no longer have any queues format: int32 type: integer autoDeleteCreatedQueues: description: whether or not to delete created queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteJmsQueues: description: DEPRECATED. whether or not to delete auto-created JMS queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteJmsTopics: description: DEPRECATED. whether or not to delete auto-created JMS topics when the last subscription is closed type: boolean autoDeleteQueues: description: whether or not to delete auto-created queues when the queue has 0 consumers and 0 messages type: boolean autoDeleteQueuesDelay: description: how long to wait (in milliseconds) before deleting auto-created queues after the queue has 0 consumers. format: int32 type: integer autoDeleteQueuesMessageCount: description: the message count the queue must be at or below before it can be evaluated to be auto deleted, 0 waits until empty queue (default) and -1 disables this check. format: int32 type: integer configDeleteAddresses: description: What to do when an address is no longer in broker.xml. OFF = will do nothing addresses will remain, FORCE = delete address and its queues even if messages remaining. type: string configDeleteQueues: description: What to do when a queue is no longer in broker.xml. OFF = will do nothing queues will remain, FORCE = delete queues even if messages remaining. type: string deadLetterAddress: description: the address to send dead messages to type: string deadLetterQueuePrefix: description: the prefix to use for auto-created dead letter queues type: string deadLetterQueueSuffix: description: the suffix to use for auto-created dead letter queues type: string defaultAddressRoutingType: description: the routing-type used on auto-created addresses type: string defaultConsumerWindowSize: description: the default window size for a consumer format: int32 type: integer defaultConsumersBeforeDispatch: description: the default number of consumers needed before dispatch can start for queues under the address. format: int32 type: integer defaultDelayBeforeDispatch: description: the default delay (in milliseconds) to wait before dispatching if number of consumers before dispatch is not met for queues under the address. format: int32 type: integer defaultExclusiveQueue: description: whether to treat the queues under the address as exclusive queues by default type: boolean defaultGroupBuckets: description: number of buckets to use for grouping, -1 (default) is unlimited and uses the raw group, 0 disables message groups. format: int32 type: integer defaultGroupFirstKey: description: key used to mark a message is first in a group for a consumer type: string defaultGroupRebalance: description: whether to rebalance groups when a consumer is added type: boolean defaultGroupRebalancePauseDispatch: description: whether to pause dispatch when rebalancing groups type: boolean defaultLastValueKey: description: the property to use as the key for a last value queue by default type: string defaultLastValueQueue: description: whether to treat the queues under the address as a last value queues by default type: boolean defaultMaxConsumers: description: the maximum number of consumers allowed on this queue at any one time format: int32 type: integer defaultNonDestructive: description: whether the queue should be non-destructive by default type: boolean defaultPurgeOnNoConsumers: description: purge the contents of the queue once there are no consumers type: boolean defaultQueueRoutingType: description: the routing-type used on auto-created queues type: string defaultRingSize: description: the default ring-size value for any matching queue which doesnt have ring-size explicitly defined format: int32 type: integer enableIngressTimestamp: description: Whether or not set the timestamp of arrival on messages. default false type: boolean enableMetrics: description: whether or not to enable metrics for metrics plugins on the matching address type: boolean expiryAddress: description: the address to send expired messages to type: string expiryDelay: description: Overrides the expiration time for messages using the default value for expiration time. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer expiryQueuePrefix: description: the prefix to use for auto-created expiry queues type: string expiryQueueSuffix: description: the suffix to use for auto-created expiry queues type: string lastValueQueue: description: This is deprecated please use default-last-value-queue instead. type: boolean managementBrowsePageSize: description: how many message a management resource can browse format: int32 type: integer managementMessageAttributeSizeLimit: description: max size of the message returned from management API, default 256 format: int32 type: integer match: description: pattern for matching settings against addresses; can use wildards type: string maxDeliveryAttempts: description: how many times to attempt to deliver a message before sending to dead letter address format: int32 type: integer maxExpiryDelay: description: Overrides the expiration time for messages using a higher value. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer maxRedeliveryDelay: description: Maximum value for the redelivery-delay format: int32 type: integer maxSizeBytes: description: the maximum size in bytes for an address. -1 means no limits. This is used in PAGING, BLOCK and FAIL policies. Supports byte notation like K, Mb, GB, etc. type: string maxSizeBytesRejectThreshold: description: used with the address full BLOCK policy, the maximum size in bytes an address can reach before messages start getting rejected. Works in combination with max-size-bytes for AMQP protocol only. Default = -1 (no limit). format: int32 type: integer messageCounterHistoryDayLimit: description: how many days to keep message counter history for this address format: int32 type: integer minExpiryDelay: description: Overrides the expiration time for messages using a lower value. \u0026quot;-1\u0026quot; disables this setting. format: int32 type: integer pageMaxCacheSize: description: Number of paging files to cache in memory to avoid IO during paging navigation format: int32 type: integer pageSizeBytes: description: The page size in bytes to use for an address. Supports byte notation like K, Mb, GB, etc. type: string redeliveryCollisionAvoidanceFactor: description: factor by which to modify the redelivery delay slightly to avoid collisions type: string redeliveryDelay: description: the time (in ms) to wait before redelivering a cancelled message. format: int32 type: integer redeliveryDelayMultiplier: description: multiplier to apply to the redelivery-delay type: string redistributionDelay: description: how long (in ms) to wait after the last consumer is closed on a queue before redistributing messages. format: int32 type: integer retroactiveMessageCount: description: the number of messages to preserve for future queues created on the matching address format: int32 type: integer sendToDlaOnNoRoute: description: if there are no queues matching this address, whether to forward message to DLA (if it exists for this address) type: boolean slowConsumerCheckPeriod: description: How often to check for slow consumers on a particular queue. Measured in seconds. format: int32 type: integer slowConsumerPolicy: description: what happens when a slow consumer is identified type: string slowConsumerThreshold: description: The minimum rate of message consumption allowed before a consumer is considered \u0026quot;slow.\u0026quot; Measured in messages-per-second. format: int32 type: integer slowConsumerThresholdMeasurementUnit: description: Unit used in specifying slow consumer threshold, default is MESSAGE_PER_SECOND type: string type: object type: array applyRule: description: How to merge the address settings to broker configuration type: string type: object adminPassword: description: Password for standard broker user. It is required for connecting to the broker and the web console. If left empty, it will be generated. type: string adminUser: description: User name for standard broker user. It is required for connecting to the broker and the web console. If left empty, it will be generated. type: string connectors: items: properties: enabledCipherSuites: description: Comma separated list of cipher suites used for SSL communication. type: string enabledProtocols: description: Comma separated list of protocols used for SSL communication. type: string expose: description: Whether or not to expose this connector type: boolean host: description: Hostname or IP to connect to type: string name: description: The name of the connector type: string needClientAuth: description: Tells a client connecting to this connector that 2-way SSL is required. This property takes precedence over wantClientAuth. type: boolean port: description: Port number format: int32 type: integer sniHost: description: A regular expression used to match the server_name extension on incoming SSL connections. If the name doesn't match then the connection to the acceptor will be rejected. type: string sslEnabled: description: ' Whether or not to enable SSL on this port' type: boolean sslProvider: description: Used to change the SSL Provider between JDK and OPENSSL. The default is JDK. type: string sslSecret: description: Name of the secret to use for ssl information type: string type: description: The type either tcp or vm type: string verifyHost: description: The CN of the connecting client's SSL certificate will be compared to its hostname to verify they match. This is useful only for 2-way SSL. type: boolean wantClientAuth: description: Tells a client connecting to this connector that 2-way SSL is requested but not required. Overridden by needClientAuth. type: boolean required: - host - name - port type: object type: array console: properties: expose: description: Whether or not to expose this port type: boolean sslEnabled: description: Whether or not to enable SSL on this port type: boolean sslSecret: description: Name of the secret to use for ssl information type: string useClientAuth: description: If the embedded server requires client authentication type: boolean type: object deploymentPlan: properties: clustered: description: Whether broker is clustered type: boolean enableMetricsPlugin: description: Whether or not to install the artemis metrics plugin type: boolean extraMounts: properties: configMaps: description: Name of ConfigMap items: type: string type: array secrets: description: Name of Secret items: type: string type: array type: object image: description: The image used for the broker deployment type: string initImage: description: The init container image used to configure broker type: string jolokiaAgentEnabled: description: If true enable the Jolokia JVM Agent type: boolean journalType: description: If aio use ASYNCIO, if nio use NIO for journal IO type: string livenessProbe: properties: timeoutSeconds: description: Liveness Probe timeoutSeconds for broker container format: int32 type: integer type: object managementRBACEnabled: description: If true enable the management role based access control type: boolean messageMigration: description: If true migrate messages on scaledown type: boolean persistenceEnabled: description: If true use persistent volume via persistent volume claim for journal storage type: boolean podSecurity: properties: runAsUser: description: runAsUser as defined in PodSecurityContext for the pod format: int64 type: integer serviceAccountName: description: ServiceAccount Name of the pod type: string type: object readinessProbe: properties: timeoutSeconds: description: Readiness Probe timeoutSeconds for broker container format: int32 type: integer type: object requireLogin: description: If true require user password login credentials for broker protocol ports type: boolean resources: description: ResourceRequirements describes the compute resource requirements. properties: limits: additionalProperties: anyOf: - type: integer - type: string pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$ x-kubernetes-int-or-string: true description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/' type: object requests: additionalProperties: anyOf: - type: integer - type: string pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$ x-kubernetes-int-or-string: true description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/' type: object type: object size: description: The number of broker pods to deploy format: int32 type: integer storage: properties: size: type: string type: object type: object upgrades: description: ActiveMQArtemis App product upgrade flags properties: enabled: description: Set to true to enable automatic micro version product upgrades, disabled by default. type: boolean minor: description: Set to true to enable automatic micro version product upgrades, disabled by default. Requires spec.upgrades.enabled true. type: boolean required: - enabled - minor type: object version: description: The version of the broker deployment. type: string type: object status: description: ActiveMQArtemisStatus defines the observed state of ActiveMQArtemis properties: podStatus: description: Pod Status properties: ready: description: Deployments are ready to serve requests items: type: string type: array starting: description: Deployments are starting, may or may not succeed items: type: string type: array stopped: description: Deployments are not starting, unclear what next step will be items: type: string type: array type: object required: - podStatus type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Address Custom Resource configuration reference # A CR instance based on the address CRD enables you to define addresses and queues for the brokers in your deployment. The following is thefull CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemisaddresses.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisAddress listKind: ActiveMQArtemisAddressList plural: activemqartemisaddresses singular: activemqartemisaddress scope: Namespaced versions: - name: v1beta1 schema: openAPIV3Schema: description: ActiveMQArtemisAddress is the Schema for the activemqartemisaddresses API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisAddressSpec defines the desired state of ActiveMQArtemisAddress properties: addressName: description: Address Name type: string applyToCrNames: description: Apply to the broker crs in the current namespace. A value of * or empty string means applying to all broker crs. Default apply to all broker crs items: type: string type: array password: description: The user's password type: string queueConfiguration: properties: autoCreateAddress: description: Whether auto create address type: boolean autoDelete: description: Auto-delete the queue type: boolean autoDeleteDelay: description: Delay (Milliseconds) before auto-delete the queue format: int64 type: integer autoDeleteMessageCount: description: Message count of the queue to allow auto delete format: int64 type: integer configurationManaged: description: ' If the queue is configuration managed' type: boolean consumerPriority: description: Consumer Priority format: int32 type: integer consumersBeforeDispatch: description: Number of consumers required before dispatching messages format: int32 type: integer delayBeforeDispatch: description: Milliseconds to wait for `consumers-before-dispatch` to be met before dispatching messages anyway format: int64 type: integer durable: description: If the queue is durable or not type: boolean enabled: description: If the queue is enabled type: boolean exclusive: description: If the queue is exclusive type: boolean filterString: description: The filter string for the queue type: string groupBuckets: description: Number of messaging group buckets format: int32 type: integer groupFirstKey: description: Header set on the first group message type: string groupRebalance: description: If rebalance the message group type: boolean groupRebalancePauseDispatch: description: If pause message dispatch when rebalancing groups type: boolean ignoreIfExists: description: If ignore if the target queue already exists type: boolean lastValue: description: If it is a last value queue type: boolean lastValueKey: description: The property used for last value queue to identify last values type: string maxConsumers: description: Max number of consumers allowed on this queue format: int32 type: integer nonDestructive: description: If force non-destructive consumers on the queue type: boolean purgeOnNoConsumers: description: Whether to delete all messages when no consumers connected to the queue type: boolean ringSize: description: The size the queue should maintain according to ring semantics format: int64 type: integer routingType: description: The routing type of the queue type: string temporary: description: If the queue is temporary type: boolean user: description: The user associated with the queue type: string required: - maxConsumers - purgeOnNoConsumers type: object queueName: description: Queue Name type: string removeFromBrokerOnDelete: description: Whether or not delete the queue from broker when CR is undeployed(default false) type: boolean routingType: description: The Routing Type type: string user: description: User name for creating the queue or address type: string type: object status: description: ActiveMQArtemisAddressStatus defines the observed state of ActiveMQArtemisAddress type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Security Custom Resource configuration reference # A CR instance based on the Security CRD enables you to define security for the brokers in your deployment. The following is the full CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemissecurities.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisSecurity listKind: ActiveMQArtemisSecurityList plural: activemqartemissecurities singular: activemqartemissecurity scope: Namespaced versions: - name: v1alpha1 schema: openAPIV3Schema: description: ActiveMQArtemisSecurity is the Schema for the activemqartemissecurities API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisSecuritySpec defines the desired state of ActiveMQArtemisSecurity properties: applyToCrNames: items: type: string type: array loginModules: properties: guestLoginModules: items: properties: guestRole: type: string guestUser: type: string name: type: string type: object type: array keycloakLoginModules: items: properties: configuration: properties: allowAnyHostName: type: boolean alwaysRefreshToken: type: boolean authServerUrl: type: string autoDetectBearerOnly: type: boolean bearerOnly: type: boolean clientKeyPassword: type: string clientKeyStore: type: string clientKeyStorePassword: type: string confidentialPort: format: int32 type: integer connectionPoolSize: format: int64 type: integer corsAllowedHeaders: type: string corsAllowedMethods: type: string corsExposedHeaders: type: string corsMaxAge: format: int64 type: integer credentials: items: properties: key: type: string value: type: string type: object type: array disableTrustManager: type: boolean enableBasicAuth: type: boolean enableCors: type: boolean exposeToken: type: boolean ignoreOauthQueryParameter: type: boolean minTimeBetweenJwksRequests: format: int64 type: integer principalAttribute: type: string proxyUrl: type: string publicClient: type: boolean publicKeyCacheTtl: format: int64 type: integer realm: type: string realmPublicKey: type: string redirectRewriteRules: items: properties: key: type: string value: type: string type: object type: array registerNodeAtStartup: type: boolean registerNodePeriod: format: int64 type: integer resource: type: string scope: type: string sslRequired: type: string tokenCookiePath: type: string tokenMinimumTimeToLive: format: int64 type: integer tokenStore: type: string trustStore: type: string trustStorePassword: type: string turnOffChangeSessionIdOnLogin: type: boolean useResourceRoleMappings: type: boolean verifyTokenAudience: type: boolean required: - enableBasicAuth type: object moduleType: type: string name: type: string type: object type: array propertiesLoginModules: items: properties: name: type: string users: items: properties: name: type: string password: type: string roles: items: type: string type: array type: object type: array type: object type: array type: object securityDomains: properties: brokerDomain: properties: loginModules: items: properties: debug: type: boolean flag: type: string name: type: string reload: type: boolean type: object type: array name: type: string type: object consoleDomain: properties: loginModules: items: properties: debug: type: boolean flag: type: string name: type: string reload: type: boolean type: object type: array name: type: string type: object type: object securitySettings: properties: broker: items: properties: match: type: string permissions: items: properties: operationType: type: string roles: items: type: string type: array required: - operationType type: object type: array type: object type: array management: properties: authorisation: properties: allowedList: items: properties: domain: type: string key: type: string type: object type: array defaultAccess: items: properties: method: type: string roles: items: type: string type: array type: object type: array roleAccess: items: properties: accessList: items: properties: method: type: string roles: items: type: string type: array type: object type: array domain: type: string key: type: string type: object type: array type: object connector: properties: authenticatorType: type: string host: type: string jmxRealm: type: string keyStorePassword: type: string keyStorePath: type: string keyStoreProvider: type: string objectName: type: string passwordCodec: type: string port: format: int32 type: integer rmiRegistryPort: format: int32 type: integer secured: type: boolean trustStorePassword: type: string trustStorePath: type: string trustStoreProvider: type: string type: object hawtioRoles: items: type: string type: array type: object type: object type: object status: description: ActiveMQArtemisSecurityStatus defines the observed state of ActiveMQArtemisSecurity type: object type: object served: true storage: false subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  Message Migration Custom Resource configuration reference # A CR instance based on the address CRD enables you to define message migration for the brokers in your deployment. The following is the full CRD yaml\napiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: annotations: controller-gen.kubebuilder.io/version: v0.7.0 creationTimestamp: null name: activemqartemisscaledowns.broker.amq.io spec: group: broker.amq.io names: kind: ActiveMQArtemisScaledown listKind: ActiveMQArtemisScaledownList plural: activemqartemisscaledowns singular: activemqartemisscaledown scope: Namespaced versions: - name: v2alpha1 schema: openAPIV3Schema: description: ActiveMQArtemisScaledown is the Schema for the activemqartemisscaledowns API properties: apiVersion: description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources' type: string kind: description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds' type: string metadata: type: object spec: description: ActiveMQArtemisScaledownSpec defines the desired state of ActiveMQArtemisScaledown properties: localOnly: description: Triggered by main ActiveMQArtemis CRD messageMigration entry type: boolean required: - localOnly type: object status: description: ActiveMQArtemisScaledownStatus defines the observed state of ActiveMQArtemisScaledown type: object type: object served: true storage: true subresources: status: {} status: acceptedNames: kind: \u0026quot;\u0026quot; plural: \u0026quot;\u0026quot; conditions: [] storedVersions: []  "}),e.add({id:7,href:"/docs/help/images/",title:"Images",description:"Images ArtemisCloud.io",content:"Overview of the ArtemisCloud Container images # Docs to Follow\nThe basic Container Image # The Basic Broker Container Image is the simplest of images to get started with, it uses environment variables to configure the broker and then starts it. You can find the basic Broker Container Image at quay.io\nThe Kubernetes Image # The Init Image # The Operator Image # "}),e.add({id:8,href:"/docs/help/operator/",title:"Operator",description:"Operator ArtemisCloud.io",content:"Overview of the ArtemisCloud Operator Custom Resource Definitions # In general, a Custom Resource Definition (CRD) is a schema of configuration items that you can modify for a custom Kubernetes object deployed with an Operator. By creating a corresponding Custom Resource (CR) instance, you can specify values for configuration items in the CRD. If you are an Operator developer, what you expose through a CRD essentially becomes the API for how a deployed object is configured and used. You can directly access the CRD through regular HTTP curl commands, because the CRD gets exposed automatically through Kubernetes.\nThe following CRD\u0026rsquo;s are available for the Operator and can be found in the Operator Repository under config/crd/bases/\n   CRD Description     Main broker CRD Create and configure a broker deployment   Address CRD Create addresses and queues for a broker deployment   Scaledown CRD Creates a Scaledown Controller for message migration   Security CRD Configure the security and authentication method of the Broker    Additional resources # To learn how to install the ActiveMQ Artemis Operator (and all included CRDs) using:\nThe Kubernetes CLI, see Installing the Operator\nFor complete configuration references to use when creating CR instances based on the main broker and address CRDs, see:\nBroker Custom Resource configuration reference\nAddress Custom Resource configuration reference\nSample Custom Reference can be found in the Operator Repository under the deploy/crs directory\nOperator deployment notes # This section describes some important considerations when planning an Operator-based deployment\nDeploying the Custom Resource Definitions (CRDs) that accompany the ActiveMQ Artemis Operator requires cluster administrator privileges for your Kubernetes cluster. When the Operator is deployed, non-administrator users can create broker instances via corresponding Custom Resources (CRs). To enable regular users to deploy CRs, the cluster administrator must first assign roles and permissions to the CRDs. For more information, see Creating cluster roles for Custom Resource Definitions in the Kubernetes documentation.\nWhen you update your cluster with the CRDs for the latest Operator version, this update affects all projects in the cluster. Any broker Pods deployed from previous versions of the Operator might become unable to update their status. To fix this issue for an affected project, you must also upgrade that project to use the latest version of the Operator.\nYou cannot create more than one broker deployment in a given Kubernetes project by deploying multiple broker Custom Resource (CR) instances. However, when you have created a broker deployment in a project, you can deploy multiple CR instances for addresses.\nIf you intend to deploy brokers with persistent storage and do not have container-native storage in your Kubernetes cluster, you need to manually provision Persistent Volumes (PVs) and ensure that these are available to be claimed by the Operator. For example, if you want to create a cluster of two brokers with persistent storage (that is, by setting persistenceEnabled=true in your CR), you need to have two persistent volumes available. By default, each broker instance requires storage of 2 GiB.\nIf you specify persistenceEnabled=false in your CR, the deployed brokers uses ephemeral storage. Ephemeral storage means that every time you restart the broker Pods, any existing data is lost.\nFor more information about provisioning persistent storage in Kubernetes, see Understanding persistent storage\nInstalling the Operator using the CLI # This section shows how to use the Kubernetes command-line interface (CLI) to deploy the latest version of the Operator for ArtemisCloud in your Kubernetes project.\nIf you intend to deploy brokers with persistent storage and do not have container-native storage in your Kubernetes cluster, you need to manually provision Persistent Volumes (PVs) and ensure that they are available to be claimed by the Operator. For example, if you want to create a cluster of two brokers with persistent storage (that is, by setting persistenceEnabled=true in your Custom Resource), you need to have two PVs available. By default, each broker instance requires storage of 2 GiB.\nIf you specify persistenceEnabled=false in your Custom Resource, the deployed brokers uses ephemeral storage. Ephemeral storage means that that every time you restart the broker Pods, any existing data is lost.\nGetting the Operator code # This procedure shows how to access and prepare the code you need to install the latest version of the Operator for ArtemisCloud .\nDownload the latest version of the Operator from https://github.com/artemiscloud/activemq-artemis-operator/tags\nWhen the download has completed, move the archive to your chosen installation directory.\n$ mkdir ~/broker/operator $ mv activemq-artemis-operator-0.18.1.zip ~/broker/operator  In your chosen installation directory, extract the contents of the archive. For example:\n$ cd ~/broker/operator $ unzip activemq-artemis-operator-0.18.1.zip  Preparing the kubernetes Environment # Switch to the directory that was created when you extracted the archive. For example:\n$ cd activemq-artemis-operator  Specify the project in which you want to install the Operator. You can create a new project or switch to an existing one.\nCreate a new namespace:\n$ kubectl create namespace \u0026lt;project-name\u0026gt;  Or, switch to an existing namespace:\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Specify a service account to use with the Operator.\nIn the deploy directory of the Operator archive that you extracted, open the service_account.yaml file.\nEnsure that the kind element is set to ServiceAccount.\nIn the metadata section, assign a custom name to the service account, or use the default name. The default name is activemq-artemis-operator.\nCreate the service account in your project.\n$ kubectl create -f deploy/service_account.yaml  Specify a role name for the Operator.\nOpen the role.yaml file. This file specifies the resources that the Operator can use and modify.\nEnsure that the kind element is set to Role.\nIn the metadata section, assign a custom name to the role, or use the default name. The default name is activemq-artemis-operator.\nCreate the role in your project.\n$ kubectl create -f deploy/role.yaml  Specify a role binding for the Operator. The role binding binds the previously-created service account to the Operator role, based on the names you specified.\nOpen the role_binding.yaml file. Ensure that the name values for ServiceAccount and Role match those specified in the service_account.yaml and role.yaml files. For example:\nmetadata: name: activemq-artemis-operator subjects: kind: ServiceAccount name: activemq-artemis-operator roleRef: kind: Role name: activemq-artemis-operator  Create the role binding in your project.\n$ kubectl create -f deploy/role_binding.yaml  In the procedure that follows, you deploy the Operator in your project.\nDeploy The Operator # Switch to the directory that was created when you previously extracted the Operator installation archive. For example:\n$ cd ~/broker/operator/amq-broker-operator--ocp-install-examples  Deploy the CRDs that are included with the Operator. You must install the CRDs in your Kubernetes cluster before deploying and starting the Operator.\nDeploy the main broker CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemis_crd.yaml  Deploy the address CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemisaddress_crd.yaml  Deploy the scaledown controller CRD.\n$ kubectl create -f deploy/crds/broker_activemqartemisscaledown_crd.yaml  In the deploy directory of the Operator archive that you downloaded and extracted, open the operator.yaml file. Ensure that the value of the spec.containers.image property is set to the latest Operator image for ActiveMQ Artemis , as shown below.\nspec: template: spec: containers: image: quay.io/artemiscloud/activemq-artemis-operator:latest  Deploy the Operator.\n$ kubectl create -f deploy/operator.yaml  In your Kubernetes project, the Operator starts in a new Pod.\nIn the Kubernetes web console, the information on the Events tab of the Operator Pod confirms that Kubernetes has deployed the Operator image that you specified, has assigned a new container to a node in your Kubernetes cluster, and has started the new container.\nIn addition, if you click the Logs tab within the Pod, the output should include lines resembling the following:\n... {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.8302743,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting Controller\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemisaddress-controller\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.830541,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting Controller\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemis-controller\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.9306898,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting workers\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemisaddress-controller\u0026quot;,\u0026quot;worker count\u0026quot;:1} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:1553619035.9311671,\u0026quot;logger\u0026quot;:\u0026quot;kubebuilder.controller\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;Starting workers\u0026quot;,\u0026quot;controller\u0026quot;:\u0026quot;activemqartemis-controller\u0026quot;,\u0026quot;worker count\u0026quot;:1}  The preceding output confirms that the newly-deployed Operator is communicating with Kubernetes, that the controllers for the broker and addressing are running, and that these controllers have started some workers.\nIt is recommended that you deploy only a single instance of the ActiveMQ Artemis Operator in a given Kubernetes project. Setting the replicas element of your Operator deployment to a value greater than 1, or deploying the Operator more than once in the same project is not recommended.\nCreating Operator-based broker deployments # Deploying a basic broker instance # The following procedure shows how to use a Custom Resource (CR) instance to create a basic broker deployment.\nNOTE: You cannot create more than one broker deployment in a given Kubernetes project by deploying multiple Custom Resource (CR) instances. However, when you have created a broker deployment in a project, you can deploy multiple CR instances for addresses.  Prerequisites\n  You must have already installed the ArtemisCloud Operator.\n  To use the Kubernetes command-line interface (CLI) to install the ActiveMQ Artemis Operator, see Installing the Operator.\n  When you have successfully installed the Operator, the Operator is running and listening for changes related to your CRs. This example procedure shows how to use a CR instance to deploy a basic broker in your project.\n Start configuring a Custom Resource (CR) instance for the broker deployment.  Using the Kubernetes command-line interface switch to the namespace you are using for your project\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Open the sample CR file called broker_activemqartemis_cr.yaml that is included in the deploy/crs directory of the Operator installation archive that you downloaded and extracted. For a basic broker deployment, the configuration might resemble that shown below. This configuration is the default content of the broker_activemqartemis_cr.yaml sample CR.\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao application: ex-aao-app spec: version: 7.7.0 deploymentPlan: size: 2 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes: ...  Observe that the sample CR uses a naming convention of ex-aao. This naming convention denotes that the CR is an example resource for the ArtemisCloud (based on the ActiveMQ Artemis project) Operator. When you deploy this sample CR, the resulting Stateful Set uses the name ex-aao-ss. Furthermore, broker Pods in the deployment are directly based on the Stateful Set name, for example, ex-aao-ss-0, ex-aao-ss-1, and so on. The application name in the CR appears in the deployment as a label on the Stateful Set. You might use this label in a Pod selector, for example.\nThe size value specifies the number of brokers to deploy. The default value of 2 specifies a clustered broker deployment of two brokers. However, to deploy a single broker instance, change the value to 1.\nThe image value specifies the container image to use to launch the broker. Ensure that this value specifies the latest version of the ActiveMQ Artemis broker container image in the Quay.io repository, as shown below.\nimage: quay.io/artemiscloud/activemq-artemis-broker-kubernetes:0.2.1  In the preceding step, the image attribute specifies a floating image tag (that is, ) rather than a full image tag (for example, -5). When you specify this floating tag, your deployment uses the latest image available in the image stream. In addition, when you specify a floating tag such as this, if the imagePullPolicy attribute in your Stateful Set is set to Always, your deployment automatically pulls and uses new micro image versions (for example, -6, -7, and so on) when they become available from quay.io. Deploy the CR instance.\nSave the CR file.\nSwitch to the namespace in which you are creating the broker deployment.\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  Create the CR.\n$ kubectl create -f \u0026lt;path/to/custom-resource-instance\u0026gt;.yaml  In the Kubernetes web console you will see a new Stateful Set called ex-aao-ss.\nClick the ex-aao-ss Stateful Set. You see that there is one Pod, corresponding to the single broker that you defined in the CR.\nWithin the Stateful Set, click the pod link and you should see the status of the pod as running. Click on the logs link in the top right corner to see the broker’s output.\nTo test that the broker is running normally, access a shell on the broker Pod to send some test messages.\nUsing the Kubernetes web console:\nClick Pods on the left menu\nClick the ex-aao-ss Pod.\nIn the top righthand corner, click the link to exec into pod\nUsing the Kubernetes command-line interface:\nGet the Pod names and internal IP addresses for your project.\n$ kubectl get pods -o wide NAME STATUS IP amq-broker-operator-54d996c Running 10.129.2.14 ex-aao-ss-0 Running 10.129.2.15  Access the shell for the broker Pod.\n$ kubectl exec --stdin --tty ex-aao-ss-0 -- /bin/bash  From the shell, use the artemis command to send some test messages. Specify the internal IP address of the broker Pod in the URL. For example:\n$ ./amq-broker/bin/artemis producer --url tcp://10.129.2.15:61616 --destination queue://demoQueue  The preceding command automatically creates a queue called demoQueue on the broker and sends a default quantity of 1000 messages to the queue.\nYou should see output that resembles the following:\nConnection brokerURL = tcp://10.129.2.15:61616 Producer ActiveMQQueue[demoQueue], thread=0 Started to calculate elapsed time ... Producer ActiveMQQueue[demoQueue], thread=0 Produced: 1000 messages Producer ActiveMQQueue[demoQueue], thread=0 Elapsed time in second : 3 s Producer ActiveMQQueue[demoQueue], thread=0 Elapsed time in milli second : 3492 milli seconds  For a complete configuration reference for the main broker Custom Resource (CR), see Broker Custom Resource configuration reference.\nDeploying clustered brokers # If there are two or more broker Pods running in your project, the Pods automatically form a broker cluster. A clustered configuration enables brokers to connect to each other and redistribute messages as needed, for load balancing.\nThe following procedure shows you how to deploy clustered brokers. By default, the brokers in this deployment use on demand load balancing, meaning that brokers will forward messages only to other brokers that have matching consumers.\nPrerequisites\n A basic broker instance is already deployed. See Deploying a basic broker instance.  Open the CR file that you used for your basic broker deployment.\nFor a clustered deployment, ensure that the value of deploymentPlan.size is 2 or greater. For example:\napiVersion: broker.amq.io/v2alpha4 kind: ActiveMQArtemis metadata: name: ex-aao application: ex-aao-app spec: version: 7.7.0 deploymentPlan: size: 4 image: quay.io/artemiscloud/activemq-artemis-broker-kubernetes: ...  Save the modified CR file.\nSwitch to projects namespace:\n$ kubectl config set-context $(kubectl config current-context) --namespace= \u0026lt;project-name\u0026gt;  At the command line, apply the change:\n$ kubectl apply -f \u0026lt;path/to/custom-resource-instance\u0026gt;.yaml  In the Kubernetes web console, additional broker Pods starts in your project, according to the number specified in your CR. By default, the brokers running in the project are clustered.\nOpen the Logs tab of each Pod. The logs show that Kubernetes has established a cluster connection bridge on each broker. Specifically, the log output includes a line like the following:\ntargetConnector=ServerLocatorImpl (identity=(Cluster-connection-bridge::ClusterConnectionBridge@6f13fb88  Applying Custom Resource changes to running broker deployments # The following are some important things to note about applying Custom Resource (CR) changes to running broker deployments:\n  You cannot dynamically update the persistenceEnabled attribute in your CR. To change this attribute, scale your cluster down to zero brokers. Delete the existing CR. Then, recreate and redeploy the CR with your changes, also specifying a deployment size.\n  The value of the deploymentPlan.size attribute in your CR overrides any change you make to size of your broker deployment via the kubectl scale command. For example, suppose you use kubectl scale to change the size of a deployment from three brokers to two, but the value of deploymentPlan.size in your CR is still 3. In this case, Kubernetes initially scales the deployment down to two brokers. However, when the scaledown operation is complete, the Operator restores the deployment to three brokers, as specified in the CR.\n  As described in Deploying the Operator using the CLI, if you create a broker deployment with persistent storage (that is, by setting persistenceEnabled=true in your CR), you might need to provision Persistent Volumes (PVs) for the ArtemisCloud Operator to claim for your broker Pods. If you scale down the size of your broker deployment, the Operator releases any PVs that it previously claimed for the broker Pods that are now shut down. However, if you remove your broker deployment by deleting your CR, ArtemisCloud Operator does not release Persistent Volume Claims (PVCs) for any broker Pods that are still in the deployment when you remove it. In addition, these unreleased PVs are unavailable to any new deployment. In this case, you need to manually release the volumes. For more information, see Releasing volumes in the Kubernetes documentation.\n  During an active scaling event, any further changes that you apply are queued by the Operator and executed only when scaling is complete. For example, suppose that you scale the size of your deployment down from four brokers to one. Then, while scaledown is taking place, you also change the values of the broker administrator user name and password. In this case, the Operator queues the user name and password changes until the deployment is running with one active broker.\n  ll CR changes – apart from changing the size of your deployment, or changing the value of the expose attribute for acceptors, connectors, or the console – cause existing brokers to be restarted. If you have multiple brokers in your deployment, only one broker restarts at a time.\n  Configuring Scheduling, Preemption and Eviction # Liveness and Readiness Probes # The Liveness and readiness Probes are used by Kubernetes to detect when the Broker is started and to check it is still alive. For full documentation on this topic refer to the Configure Liveness, Readiness and Startup Probes chapter in the Kubernetes documentation.\nThe Liveness probe # The Liveness probe is configured in the Artemis CR something like:\nspec: deploymentPlan: size: 1 image: placeholder livenessProbe: initialDelaySeconds: 5 periodSeconds: 5  If no Liveness probe is configured or the handler itself is missing from a configured Liveness Probe then the Operator will create a default TCP Probe that will check the liveness of the broker by connecting to the web Server port, the default config is:\nspec: deploymentPlan: livenessProbe: tcpSocket: port: 8181 initialDelaySeconds: 30, timeoutSeconds: 5,  Using the Artemis Health Check # you can also use the Artemis Health Checker to check that the broker is running, something like:\nspec: deploymentPlan: livenessProbe: exec: command: - /home/jboss/amq-broker/bin/artemis - check - node - --silent - --user - $AMQ_USER - --password - $AMQ_PASSWORD initialDelaySeconds: 30, timeoutSeconds:  By default this uses the URI of the acceptor configured with the name artemis. Since this is not configured by default it will need configuring in the broker CR. Alternatively configure the acceptor used by passing the \u0026ndash;acceptor argument on the artemis check command.\nNOTE: $AMQ_USER and $AMQ_PASSWORD are environment variables that are configured by the Operator  You can also check the status of the broker by producing and consuming a message:\nspec: deploymentPlan: livenessProbe: exec: command: - /home/jboss/amq-broker/bin/artemis - check - queue - --name - livenessqueue - --produce - \u0026quot;1\u0026quot; - --consume - \u0026quot;1\u0026quot; - --silent - --user - $AMQ_USER - --password - $AMQ_PASSWORD initialDelaySeconds: 30, timeoutSeconds:  The liveness queue must exist and be deployed the broker and be of type anycast with acceptable configuration, something like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemisAddress metadata: name: livenessqueue namespace: activemq-artemis-operator spec: addressName: livenessqueue queueConfiguration: purgeOnNoConsumers: false maxConsumers: -1 durable: true enabled: true queueName: livenessqueue routingType: anycast  NOTE: The livenessqueue queue above should should only be used by the livness probe.  The Readiness Probe # As with the Liveness Probe the Readiness probe has a default probe if not configured. Unlike the readiness probe this is a script that is shipped in the Kubernetes Image, this can be found here\nThe script will try to establish a tcp connection to each port configured in the broker.xml.\nTolerations # It is possible to configure tolerations on tge deployed broker image . An example of a toleration would be something like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: size: 1 tolerations: - key: \u0026quot;example-key\u0026quot; operator: \u0026quot;Exists\u0026quot; effect: \u0026quot;NoSchedule\u0026quot;  The use of Taints and Tolerations is outside the scope of this document, for full documentation see the Kubernetes Documentation\nAffinity # It is possible to configure Affinity for the container pods, An example of this would be:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: disktype operator: In values: - ssd acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  Affinity is outside the scope of this document, for full documentation see the Kubernetes Documentation\nLabels and Node Selectors # Labels can be added to the pods by defining them like so:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: labels: location: \u0026quot;production\u0026quot; partition: \u0026quot;customerA\u0026quot; acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  It is also possible to configure a Node Selector for the container pods, this is configured like:\napiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: broker namespace: activemq-artemis-operator spec: deploymentPlan: nodeSelector: location: \u0026quot;production\u0026quot; acceptors: - name: \u0026quot;artemis\u0026quot; port: 61617 protocols: core  labels Node Selectors are outside the scope of this document, for full documentation see the Kubernetes Documentation\n"}),e.add({id:9,href:"/docs/",title:"Docs",description:"Docs ArtemisCloud.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()